/****************************************************************************** * * Copyright (c) 2002 Palm, Inc. or its subsidiaries. * All rights reserved. * * File: BmpRsrc.h * * Description: * 		This file defines structures for bitmap objects which can be stored *		in resources.  The bitmap format for these is well defined and *		supported, and you have access to the internals.  This header is *      intended for 68K code, the structures should be assumed to be *      "big endian" and 2-byte aligned. * *****************************************************************************/#ifndef __BMPRSRC_H__#define __BMPRSRC_H__#include <PalmTypes.h>// BmpRsrc version numbers#define BmpRsrcVersionZero		0#define BmpRsrcVersionOne		1#define BmpRsrcVersionTwo		2#define BmpRsrcVersionThree		3// Compression Types for BmpRsrcVersionTwotypedef enum BmpRsrcCompressionTag{	BmpRsrcCompressionTypeScanLine = 0,	BmpRsrcCompressionTypeRLE,	BmpRsrcCompressionTypePackBits,		BmpRsrcCompressionTypeEnd		// must follow last compression algorithm} BmpRsrcCompressionType;/*// pixel format defined with BmpRsrcVersionThreetypedef enum PixelFormatTag{	pixelFormatIndexed,				// standard for Palm 68k;  standard for BMPs	pixelFormat565,					// standard for Palm 68k	pixelFormat565LE,				// standard for BMPs;  popular on ARM hardware	pixelFormatIndexedLE			// popular on ARM hardware} PixelFormatType;// constants used by density fieldtypedef enum DensityTag {	kDensityLow				=  72,	kDensityOneAndAHalf		= 108,	kDensityDouble			= 144,	kDensityTriple			= 216,	kDensityQuadruple		= 288} DensityType;*/typedef enum BmpRsrcFlag{	// These flags enumerate the BmpRsrcFlagsType bitfield	kCompressedFlag = 0,	kHasColorTableFlag,	kHasTransparencyFlag,	kIndirectFlag,	kPrivate4Flag,	kDirectColorFlag,	kIndirectColorTableFlag,	kNoDitherFlag} BmpRsrcFlagEnum;typedef struct BmpRsrcFlagsType{	UInt16 	compressed:1;  					// Data format:  0=raw; 1=compressed	UInt16 	hasColorTable:1;				// if true, color table stored before bits[], only for >= v1	UInt16 	hasTransparency:1;				// true if transparency is used, only for >= v2	UInt16 	indirect:1;						// true if bits are stored indirectly, only for >= v2	UInt16 	private:1;						// system use only, must be 0	UInt16	directColor:1;					// direct color bitmap (16 bit color, for example)	UInt16	indirectColorTable:1;			// if true, color table pointer follows BitmapType structure	UInt16	noDither:1;						// if true, blitter does not dither	UInt16 	reserved:8;} BmpRsrcFlagsType;typedef struct BmpRsrcV0Type {	Int16				width;				// >= 0	Int16				height;				// >= 0	UInt16				rowBytes;			// (width*pixelSize+15)>>4<<1	BmpRsrcFlagsType	flags;				// defigned in Bitmap.h	UInt16				reserved[4];		// set all elements to 0	// UInt8 bits[]} BmpRsrcV0Type;typedef struct BmpRsrcV1Type{	Int16				width;				// >= 0	Int16				height;				// >= 0	UInt16				rowBytes;			// (width*pixelSize+15)>>4<<1	BmpRsrcFlagsType flags;	UInt8				pixelSize;			// 1, 2, 4, 8, 16	UInt8				version;			// 1		UInt16				nextDepthOffset;	// longword offset to next member in family	UInt16				reserved[2];		// ColorTableType (if flags.hasColorTable)		// BitmapDirectInfoType (if pixelSize == 16)	// UInt8 bits[]							// actual bits start here, rowBytes * height bytes total.} BmpRsrcV1Type;typedef struct BmpRsrcV2Type{	Int16				width;				// >= 0	Int16				height;				// >= 0	UInt16				rowBytes;			// (width*pixelSize+15)>>4<<1	BmpRsrcFlagsType	flags;	UInt8				pixelSize;			// 1, 2, 4, 8, 16	UInt8				version;			// 2		UInt16				nextDepthOffset;	// longword offset to next member in family, 0 for none/last	UInt8				transparentIndex;	UInt8				compressionType;	UInt16				reserved;		// ColorTableType (if flags.hasColorTable)		// BitmapDirectInfoType (if pixelSize==16)	// if (flags.indirect)	//		UInt8*  bitsP					// 4 bytes with pointer to actual bits	// else	//		UInt8 bits[]					// actual bits start here, rowBytes * height bytes total.} BmpRsrcV2Type;typedef struct BmpRsrcV3Type{	Int16				width;				// >= 0	Int16				height;				// >= 0	UInt16				rowBytes;			// (width*pixelSize+15)>>4<<1	BmpRsrcFlagsType	flags;		UInt8				pixelSize;			// 1, 2, 4, 8, 16	UInt8				version;			// 3		UInt8				size;				// size of this structure in bytes (0x16)	UInt8				pixelFormat;		// format of the pixel data, see pixelFormatType	UInt8				unused;	UInt8				compressionType;	// see BitmapCompressionType	UInt16				density;			// used by the blitter to scale bitmaps	UInt32				transparentValue;	// the index or RGB value of the transparent color	UInt32				nextBitmapOffset;	// byte (not longword!) offset to next member in family		// if (flags.hasColorTable)	//		{	//		if (flags.indirectColorTable)	//			ColorTableType* colorTableP;	// pointer to color table	//		else	//	  		ColorTableType	colorTable;		// color table, could have 0 entries (2 bytes long)	//		}	//	// if (flags.indirect)	//		UInt8*  bitsP					// 4 bytes with pointer to actual bits	// else	//		UInt8 bits[]					// actual bits start here, rowBytes * height bytes total.} BmpRsrcV3Type;typedef union BmpRsrcType{	BmpRsrcV0Type v0;	BmpRsrcV2Type v1;	BmpRsrcV2Type v2;	BmpRsrcV3Type v3;} BmpRsrcType;// BitmapFamily is a series of BmpRsrcTypes in ascending order of depth.// if there are high density images, then there is a dummy (BmpRsrcV1Type with pixelSize = 0xFF)// followed by the high density images in ascending order of depth.#ifdef __cplusplusextern          "C"{#endif// these are all just convenience routines -- you can do everything yourself with the above declarationsBmpRsrcType * BmpRsrcCreate(Int16 width, Int16 height,								Int16 pixelSize,  // 1, 2, 4, 8, 16								const ColorTableType * ct,  // null for no color table (preferred)								Int16 density, // only kDensityLow, kDensityDouble supported								PixelFormatType pixelFormat);void BmpRsrcDelete(BmpRsrcType * bmp);// constructors for specific formats (cross-device compatibility)BmpRsrcType * BmpRsrcV0Create(Int16 width, Int16 height);BmpRsrcType * BmpRsrcV2Create(Int16 width, Int16 height,								Int16 pixelSize, // 1, 2, 4, 8, 16								const ColorTableType * ct, // null for no color table (preferred)								const UInt8 * indirectBits // null for inline bitmap								);BmpRsrcType * BmpRsrcV3Create(Int16 width, Int16 height,								Int16 pixelSize, // 1, 2, 4, 8, 16								const ColorTableType * ct,  // null for no color table (preferred)								const UInt8 * indirectBits, // null for inline bitmap								Int16 density, // only kDensityLow, kDensityDouble supported								PixelFormatType pixelFormat								);								// copy constructor, sortaBmpRsrcType * BmpRsrcCreateIndirectCopy(const BmpRsrcType * bmp);// simple accessorsinline Int16 BmpRsrcGetWidth(const BmpRsrcType * bmp) { return bmp->v0.width; }inline Int16 BmpRsrcGetHeight(const BmpRsrcType * bmp) { return bmp->v0.height; }inline Int16 BmpRsrcGetRowBytes(const BmpRsrcType * bmp) { return bmp->v0.rowBytes; }inline Boolean BmpRsrcGetFlag(const BmpRsrcType * bmp, BmpRsrcFlagEnum which) { return (*(UInt16*)(&bmp->v0.flags) & (0x8000>>which)) ? 1 : 0; }inline Int16 BmpRsrcGetVersion(const BmpRsrcType * bmp) { return bmp->v2.version; }inline Int16 BmpRsrcGetPixelSize(const BmpRsrcType * bmp) { return bmp->v2.pixelSize==0 ? 1 : bmp->v2.pixelSize; }// complex accessorsInt32 BmpRsrcGetTotalSize(const BmpRsrcType * bmp);UInt8 * BmpRsrcGetBits(const BmpRsrcType * bmp);UInt32 BmpRsrcGetTransparentValue(const BmpRsrcType * bmp);ColorTableType * BmpRsrcGetColorTable(const BmpRsrcType * bmp);inline Int16 BmpRsrcGetDensity(const BmpRsrcType * bmp) { return bmp->v3.version==3 ? bmp->v3.density : 72; }PixelFormatType BmpRsrcGetPixelFormat(const BmpRsrcType * bmp);void BmpRsrcSetFlag(BmpRsrcType * bmp, BmpRsrcFlagEnum which, Boolean value);void BmpRsrcSetTransparentValue(BmpRsrcType * bmp, UInt32 value);void BmpRsrcSetDensity(BmpRsrcType * bmp, Int16 density);// accessing pixelsUInt32 BmpRsrcBlackPixelValue(const BmpRsrcType * bmp);UInt32 BmpRsrcWhitePixelValue(const BmpRsrcType * bmp);IndexedColorType BmpRsrcBlackPixelIndex(const BmpRsrcType * bmp);IndexedColorType BmpRsrcWhitePixelIndex(const BmpRsrcType * bmp);UInt32 BmpRsrcGetPixel(const BmpRsrcType * bmp, Int16 x, Int16 y);void BmpRsrcSetPixel(BmpRsrcType * bmp, Int16 x, Int16 y, UInt32 value);// bitmap familiesconst BmpRsrcType * BmpRsrcGetNextMemberFromFamily(const BmpRsrcType * bmpFamily);BmpRsrcType * BmpRsrcBestMemberFromFamily(const BmpRsrcType * bmpFamily);#ifdef __cplusplus}#endif#endif							// __BMPRSRC_H__