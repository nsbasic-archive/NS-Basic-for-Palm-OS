/****************************************************************************** * * File: NSB_SSM.C * Description: *      Library for NSBasic with Treo devices * * History: *		5/22/01 Created by EMP * *****************************************************************************/#include <PalmOS.h>			// Includes all Palm OS headers#include <Rect.h>				// for RectangleType#include <Window.h>			// for WinDrawRectangle// Our library public definitions (library API)#define BUILDING_SAMPLE_LIB#include "NSB_SSMLib.h"// Our library private definitions (library globals, etc.)#include "NSB_SSMLibPrv.h"/* Structure required by ssm for open */typedef struct{    UInt16 oneInMe0;    UInt16 baudRate;    UInt16 oneInMe1;    UInt16 oneInMe2;    UInt16 clearMe;} OpenStruct;  // Definitions for SSM library, empirically foundextern Err SSMLibOpen(UInt16 refNum, OpenStruct * clientContextP)                      SYS_TRAP(0xA801);//extern Err SSMLibClose(UInt16 refNum, UInt32 something)//                      SYS_TRAP(0xA802);extern Err SSMGetDecodedData(UInt16 refNum, UInt8 *data)                      SYS_TRAP(0xA806);extern Err SSMSendCmd(UInt16 refNum, UInt32 *cmdAddr, UInt16 cmdHighByte)                      SYS_TRAP(0xA807);extern Err SSMSendParameters(UInt16 refNum, UInt16 beepo)                      SYS_TRAP(0xA808);extern Err SSMSetParameters(UInt16 refNum, UInt16 p1, UInt16 p2, UInt32 p3)                      SYS_TRAP(0xA809);extern Err SSMGetParameter(UInt16 refNum, UInt16 p1)                      SYS_TRAP(0xA80A);extern Err SSMLibInit(UInt16 refNum, UInt16 *something)                      SYS_TRAP(0xA813);//extern Err SSMLibDeInit(UInt16 refNum)//                      SYS_TRAP(0xA814);extern Err SSMMagicBytes(UInt16 refNum, UInt32 magicBytes)                      SYS_TRAP(0xA815);extern Err SSGetSomething(UInt16 refNum, UInt16 what)                      SYS_TRAP(0xA816);/******************************************************************** * LIBRARY GLOBALS: * * IMPORTANT: * ========== * Libraries are *not* allowed to have global or static variables.  Instead, * they allocate a memory chunk to hold their persistent data, and save * a handle to it in the library's system library table entry.  Example *	functions below demostrate how the library "globals" chunk is set up, saved, * and accessed. * * We use a movable memory chunk for our library globals to minimize * dynamic heap fragmentation.  Our library globals are locked only *	when needed and unlocked as soon as possible.  This behavior is * critical for healthy system performance. * ********************************************************************//******************************************************************** * Internally used data structures ********************************************************************/#define MAX_PACKET_LENGTH       258typedef struct  tagMESSAGE{	int length; // length of the data	int type;	// contains the barcode type when the msg is DecodeData	int status; // should be STATUS_OK	unsigned char data[MAX_PACKET_LENGTH]; // the message data} MESSAGE;/******************************************************************** * Internally used routines ********************************************************************/static NSB_SSMLibGlobalsPtr PrvMakeGlobals(UInt16 refNum);static void PrvFreeGlobals(UInt16 refNum);static NSB_SSMLibGlobalsPtr PrvLockGlobals(UInt16 refNum);static Boolean PrvIsLibOpen(UInt16 refNum);static Err PrvCreateClientContext(NSB_SSMLibGlobalsPtr gP, UInt32 * clientContextP);static Err PrvDestroyClientContext(NSB_SSMLibGlobalsPtr gP, UInt32 clientContext);static NSB_SSMLibClientContextPtr PrvLockContext(UInt32 context);static UInt16 IsPalmSymbolUnit(void);/******************************************************************** * Internally used macros ********************************************************************/// Unlock globals#define PrvUnlockGlobals(gP)	MemPtrUnlock(gP)// Unlock the client context#define PrvUnlockContext(contextP)	MemPtrUnlock(contextP)#define WITHGLOBALS if (IsPalmSymbolUnit()) {NSB_SSMLibGlobalsPtr gP = PrvLockGlobals(refNum); \                    ErrFatalDisplayIf(gP == NULL, "Cannot get SSM globals");#define SSMLIBREFNUM (gP -> ssmLibRefNum)#define ENDWITHGLOBALS PrvUnlockGlobals(gP); } // LIBRARY VERSION//// The library version scheme follows the system versioning scheme.// See sysMakeROMVersion and friends in SystemMgr.h.//// For reference://// 0xMMmfsbbb, where MM is major version, m is minor version// f is bug fix, s is stage: 3-release,2-beta,1-alpha,0-development,// bbb is build number for non-releases // V1.12b3   would be: 0x01122003// V2.00a2   would be: 0x02001002// V1.01     would be: 0x01013000#define prvSampleLibVersion	sysMakeROMVersion(1, 0, 0, sysROMStageDevelopment, 1)/******************************************************************** * NSB_SSM Library API Routines ********************************************************************//************************************************************ * *  FUNCTION: NSB_SSMLibOpen * *  DESCRIPTION:	Opens the Sample library, creates and initializes the globals. *						This function must be called before any other Sample Library functions, *						with the exception of SampleLibGetLibAPIVersion. * *						If SampleLibOpen fails, do not call any other Sample library API functions. *						If SampleLibOpen succeeds, call SampleLibClose when you are done using *						the library to enable it to release critical system resources. * *  LIBRARY DEVELOPER NOTES: * *						The library's "open" and "close" functions should *not* take an excessive *						amount of time to complete.  If the processing time for either of these *						is lengthy, consider creating additional library API function(s) to handle *						the time-consuming chores. * * *  PARAMETERS:	refNum				-- Sample library reference number returned by SysLibLoad() *										   	   or SysLibFind(). * *  CALLED BY:		anyone who wants to use this library * *  RETURNS:		0							-- no error *						sampleErrMemory		-- not enough memory to initialize * *  CREATED:	5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/Err NSB_SSMLibOpen(UInt16 refNum){	NSB_SSMLibGlobalsPtr	gP;	Err						err = 0;	Int16						originalOpenCount = 0;    char buf[20];    char *b;    	// Get library globals	gP = PrvLockGlobals(refNum);										// lock our library globals		// Check if already open	if (!gP)		{		// Allocate and initialize our library globals.		gP = PrvMakeGlobals(refNum);									// returns locked globals on success		if ( !gP )			err = sampleErrMemory;		}	    gP->openCount++;		PrvUnlockGlobals(gP);											// unlock our library globals    buf[0] = 'o';    buf[1] = 'p';    buf[2] = 'e';    buf[3] = 'n';    buf[4] = ' ';    StrIToA(&(buf[5]), gP -> openCount);    b = buf;    while (*b) ++b;    *b++ = ' ';    StrIToA(b, refNum);    SysFatalAlert(buf);        /* Try to open the library */    {    	// Get library globals    	OpenStruct fooBar;    	WITHGLOBALS										// lock our library globals    	    	fooBar.oneInMe0 = fooBar.oneInMe1 = fooBar.oneInMe2 = 1;    	fooBar.baudRate = 9600;    	fooBar.clearMe = 0;    	        err = SysLibFind("ScanMgrLib", &(SSMLIBREFNUM));    	if (err) err = SysLibLoad('libr', 'STSM', &(SSMLIBREFNUM));        err = SSMLibOpen(SSMLIBREFNUM, &(fooBar));        ErrFatalDisplayIf(err, "Could not open NSB_SSM");        err = SSMLibInit(SSMLIBREFNUM, &(fooBar.oneInMe1));        ErrFatalDisplayIf(err, "Could not initialize NSB_SSM");                        /* Enable the scanner */        SSMMagicBytes(SSMLIBREFNUM, 11272193L);        /* Set the triggering mode to HOST */        SSMSetParameters(SSMLIBREFNUM, 138, 8, 8);        SSMSendParameters(SSMLIBREFNUM, 0);        ENDWITHGLOBALS    }	return( err );}asm SSMLibMajorClose(UInt16 refNum);asm SSMLibMajorClose(UInt16 refNum){          link      a6,#0          move.l    d4,-(a7)          move.l    d3,-(a7)          moveq     #0,d4          moveq     #0,d3          move.w    8(a6),-(a7)          trap      #15          dc.w      0xA814          move.l    d4,-(a7)          move.w    8(a6),-(a7)          trap      #15          dc.w      0xA802          move.w    d0,d3          trap		#15          dc.w		0xA12C          move.w    d3,d0          addq.w    #8,a7          move.l    (a7)+,d3          move.l    (a7)+,d4          unlk      a6          rts}/************************************************************ * *  FUNCTION: SampleLibClose * *  DESCRIPTION:	Closes the Sample libary, frees globals. * *						***IMPORTANT*** *						May be called only if SampleLibOpen succeeded. * *						If other applications still have the library open, decrements *						the reference count and returns sampleErrStillOpen. * * *  LIBRARY DEVELOPER NOTES: * *						The library's "open" and "close" functions should *not* take an excessive *						amount of time to complete.  If the processing time for either of these *						is lengthy, consider creating additional library API function(s) to handle *						the time-consuming chores. *							 * *  PARAMETERS:	refNum				-- Sample library reference number returned by SysLibLoad() *												   or SysLibFind(). * *  CALLED BY:		Whoever wants to close the Sample library * *  RETURNS:		0							-- no error *						sampleErrStillOpen	-- library is still open by others (no error) * *  CREATED:	5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/Err NSB_SSMLibClose(UInt16 refNum){	NSB_SSMLibGlobalsPtr	gP;	Int16						openCount;	Err						err = 0;	Char buf[20];	char *b;		    /* Try to close the library */        if (IsPalmSymbolUnit())    {        WITHGLOBALS										// lock our library globals            buf[0] = 'c';    buf[1] = 'l';    buf[2] = 'o';    buf[3] = 's';    buf[4] = ' ';    StrIToA(&(buf[5]), gP -> openCount);    b = buf;    while (*b) ++b;    *b++ = ' ';    StrIToA(b, refNum);    SysFatalAlert(buf);       // Disable the scanner        SSMMagicBytes(SSMLIBREFNUM, 11272192L);    buf[0] = 'm';    buf[1] = 'a';    buf[2] = 'g';    buf[3] = 'b';    buf[4] = ' ';    StrIToA(&(buf[5]), gP -> openCount);    b = buf;    while (*b) ++b;    *b++ = ' ';    StrIToA(b, refNum);    SysFatalAlert(buf);        SSMLibMajorClose(gP -> ssmLibRefNum);            buf[0] = 'm';    buf[1] = 'a';    buf[2] = 'j';    buf[3] = 'r';    buf[4] = ' ';    StrIToA(&(buf[5]), gP -> openCount);    b = buf;    while (*b) ++b;    *b++ = ' ';    StrIToA(b, refNum);    SysFatalAlert(buf);        //SSMLibDeInit(gP -> ssmLibRefNum);        //SSMLibClose(gP -> ssmLibRefNum, 0);        	    // Has a problem with some symbols?	    //SysLibRemove(gP -> ssmLibRefNum);    	// Unlock the globals        ENDWITHGLOBALS    }	gP = PrvLockGlobals(refNum);	// lock our globals		// If not open, return	if (!gP)		{		return 0;						// MUST return zero here to get around a bug in system v1.x that											// would cause SysLibRemove to fail.		}		// Decrement our library open count	gP->openCount--;		// Error check for open count underflow	ErrFatalDisplayIf(gP->openCount < 0, "Sample lib open count underflow");			// Save the new open count count	openCount = gP->openCount;		PrvUnlockGlobals(gP);			// unlock our globals			// If open count reached zero, free our library globals	if ( openCount <= 0 )		{				// Free our library globals		PrvFreeGlobals(refNum);		}	else		err = sampleErrStillOpen;	// return this error code to inform the caller											// that others are still using this library    buf[0] = 'r';    buf[1] = 'e';    buf[2] = 't';    buf[3] = 'u';    buf[4] = 'r';    buf[5] = 'n';    buf[6] = ' ';    buf[7] = '\0';    SysFatalAlert(buf);	return err;}/************************************************************ * *  FUNCTION: SampleLibSleep * *  DESCRIPTION:	Handles system sleep notification. * *						***IMPORTANT*** *						This notification function is called from a system interrupt. *						It is only allowed to use system services which are interrupt- *						safe.  Presently, this is limited to EvtEnqueueKey, SysDisableInts, *						SysRestoreStatus.  Because it is called from an interrupt, *						it must *not* take a long time to complete to preserve system *						integrity.  The intention is to allow system-level libraries *						to disable hardware components to conserve power while the system *						is asleep. * *  PARAMETERS:	refNum		-- Sample library reference number * *  CALLED BY:		System * *  RETURNS:		0						-- no error * *  CREATED:	5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/Err NSB_SSMLibSleep(UInt16 refNum){	return( 0 );}/************************************************************ * *  FUNCTION: SampleLibWake * *  DESCRIPTION:	Handles system wake notification * *						***IMPORTANT*** *						This notification function is called from a system interrupt. *						It is only allowed to use system services which are interrupt- *						safe.  Presently, this is limited to EvtEnqueueKey, SysDisableInts, *						SysRestoreStatus.  Because it is called from an interrupt, *						it must *not* take a long time to complete to preserve system *						integrity.  The intention is to allow system-level libraries *						to enable hardware components which were disabled when the system *						went to sleep. * *  PARAMETERS:	refNum		-- Sample library reference number * *  CALLED BY:	System * *  RETURNS:	0						-- no error * *  CREATED:	5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/Err NSB_SSMLibWake(UInt16 refNum){	return( 0 );}static UInt16 IsPalmSymbolUnit(void){    UInt32 versionQ;    Err err;    err = FtrGet('psys', 1, &versionQ);        if (err || (versionQ < 50331648))    {        return 0;    }    else    {        UInt16 size = 4;        UInt8 token[4];        UInt8 *tokenP = &(token[0]);        err = SysGetROMToken(0, 'scnr', &tokenP, &size);        if (err)        {            return 0;        }        else        {            return 1;        }    }}/** * Return true in the second argument if this box is a Symbol unit */Err NSB_SSMLibIsPalmSymbolUnit(UInt16 refNum, UInt32 *isit){    *isit = IsPalmSymbolUnit();    return 0;}/** * Turn LED on */Err NSB_SSMLibCmdScanLedOn(UInt16 refNum){    Err retVal;    WITHGLOBALS	    retVal = SSMMagicBytes(SSMLIBREFNUM, 11337729L);    ENDWITHGLOBALS	return 0;}/** * Turn LED off */Err NSB_SSMLibCmdScanLedOff(UInt16 refNum){    Err retVal;    WITHGLOBALS	    retVal = SSMMagicBytes(SSMLIBREFNUM, 11337728L);    ENDWITHGLOBALS		return 0;}/** * Enable the scanner */Err NSB_SSMLibCmdScanEnable(UInt16 refNum){    Err retVal;    WITHGLOBALS	    retVal = SSMMagicBytes(SSMLIBREFNUM, 11272193L);    ENDWITHGLOBALS		return retVal;}/** * Set the triggering modes */Err NSB_SSMLibCmdScanSetTriggeringModes(UInt16 refNum, UInt32 modes){    Err retVal;     WITHGLOBALS        if (modes == 0 || modes == 2 || modes == 8)    {        retVal = SSMSetParameters(SSMLIBREFNUM, 138, (UInt16) modes, 8);         SSMSendParameters(SSMLIBREFNUM, 0);    }    else    {        ErrFatalDisplay("Invalid triggering mode");        retVal = -4;    }    ENDWITHGLOBALS				return retVal;}/** * Set barcodes */Err NSB_SSMLibCmdScanSetBarcodeEnabled(UInt16 refNum, UInt32 barCode, UInt32 whether){    Err retVal;    WITHGLOBALS	    retVal = SSMSetParameters(SSMLIBREFNUM, (UInt16) barCode, (UInt16) whether, 1);    SSMSendParameters(SSMLIBREFNUM, 0);    ENDWITHGLOBALS		return retVal;}/** * Start decoding */Err NSB_SSMLibCmdStartDecode(UInt16 refNum){    Err retVal;    UInt32 startCmd = 0x04E40400L;    WITHGLOBALS	    retVal = SSMSendCmd(SSMLIBREFNUM, &startCmd, (startCmd >> 16) & 0xFF00);    ENDWITHGLOBALS		return retVal;}/** * Stop decoding */Err NSB_SSMLibCmdStopDecode(UInt16 refNum){    Err retVal;    UInt32 stopCmd = 0x04E50400L;        WITHGLOBALS    retVal = SSMSendCmd(SSMLIBREFNUM, &stopCmd, (stopCmd >> 16) & 0xFF00);    ENDWITHGLOBALS		return retVal;}/** * Send parameters */Err NSB_SSMLibCmdSendParams(UInt16 refNum, UInt32 beepo){    Err retVal;        WITHGLOBALS	    retVal = SSMSendParameters(SSMLIBREFNUM, (UInt16) beepo);    ENDWITHGLOBALS		return retVal;}/** * Disable the scanner */Err NSB_SSMLibCmdScanDisable(UInt16 refNum){    Err retVal;    WITHGLOBALS    retVal = SSMMagicBytes(SSMLIBREFNUM, 11272192L);    ENDWITHGLOBALS    		return retVal;}/** * Get the decoded data into a buffer */Err NSB_SSMLibGetDecodedData(UInt16 refNum, UInt8 *buffer){    Err retVal = 0;        WITHGLOBALS    retVal = SSMGetDecodedData(SSMLIBREFNUM, buffer);    ENDWITHGLOBALS        return retVal;}//	Resource: tSTR 3100#define BCTypeNotApplicableString                 3100	// "Not Applicable"//	Resource: tSTR 3200#define BCTypeCode39String                        3200	// "Code 39"//	Resource: tSTR 3300#define BCTypeCodabarString                       3300	// "Codabar"//	Resource: tSTR 3400#define BCTypeCode128String                       3400	// "Code 128"//	Resource: tSTR 3500#define BCTypeDiscrete2Of5String                  3500	// "Discrete 2 of 5"//	Resource: tSTR 3600#define BCTypeIATA2of5String                      3600	// "IATA 2 of 5"//	Resource: tSTR 3700#define BCTypeInterleaved2Of5String               3700	// "Interleaved 2 of 5"//	Resource: tSTR 3800#define BCTypeCode93String                        3800	// "Code 93"//	Resource: tSTR 3900#define BCTypeUPCAString                          3900	// "UPC A"//	Resource: tSTR 4000#define BCTypeUPCA2SuppsString                    4000	// "UPC A with 2 Supps."//	Resource: tSTR 4100#define BCTypeUPCA5SuppsString                    4100	// "UPC A with 5 Supps."//	Resource: tSTR 4200#define BCTypeUPCEOString                         4200	// "UPC EO"//	Resource: tSTR 4300#define BCTypeUPCEO2SuppsString                   4300	// "UPC EO with 2 Supps."//	Resource: tSTR 4400#define BCTypeUPCEO5SuppsString                   4400	// "UPC EO with 5 Supps."//	Resource: tSTR 4500#define BCTypeEAN8String                          4500	// "EAN 8"//	Resource: tSTR 4600#define BCTypeEAN82SuppsString                    4600	// "EAN 8 with 2 Supps."//	Resource: tSTR 4700#define BCTypeEAN85SuppsString                    4700	// "EAN 8 with 5 Supps."//	Resource: tSTR 4800#define BCTypeEAN13String                         4800	// "EAN 13"//	Resource: tSTR 4900#define BCTypeEAN132SuppsString                   4900	// "EAN 13 with 2 Supps."//	Resource: tSTR 5000#define BCTypeEAN135SuppsString                   5000	// "EAN 13 with 5 Supps."//	Resource: tSTR 5100#define BCTypeMSIPlesseyString                    5100	// "MSI Plessey"//	Resource: tSTR 5200#define BCTypeEAN128String                        5200	// "EAN 128"//	Resource: tSTR 5300#define BCTypeUPCE1String                         5300	// "UPC E1"//	Resource: tSTR 5400#define BCTypeUPCE12SuppsString                   5400	// "UPC E1 with 2 Supps."//	Resource: tSTR 5500#define BCTypeUPCE15SuppsString                   5500	// "UPC E1 with 5 Supps."//	Resource: tSTR 5600#define BCTypeTriopticCode39String                5600	// "Trioptic Code 39"//	Resource: tSTR 5700#define BCTypeBooklandEANString                   5700	// "Bookland EAN"//	Resource: tSTR 5800#define BCTypeCouponCodeString                    5800	// "Coupon Code"// barcode data types returned along with the decode data...    #define BCTYPE_NOT_APPLICABLE                       0x00    #define BCTYPE_CODE39                               0x01    #define BCTYPE_CODABAR                              0x02    #define BCTYPE_CODE128                              0x03    #define BCTYPE_D2OF5                                0x04    #define BCTYPE_IATA2OF5                             0x05    #define BCTYPE_I2OF5                                0x06    #define BCTYPE_CODE93                               0x07    #define BCTYPE_UPCA                                 0x08    #define BCTYPE_UPCA_2SUPPLEMENTALS                  0x48    #define BCTYPE_UPCA_5SUPPLEMENTALS                  0x88    #define BCTYPE_UPCE0                                0x09    #define BCTYPE_UPCE0_2SUPPLEMENTALS                 0x49    #define BCTYPE_UPCE0_5SUPPLEMENTALS                 0x89    #define BCTYPE_EAN8                                 0x0A    #define BCTYPE_EAN8_2SUPPLEMENTALS                  0x4A    #define BCTYPE_EAN13_5SUPPLEMENTALS                 0x8B    #define BCTYPE_EAN8_5SUPPLEMENTALS                  0x8A    #define BCTYPE_EAN13                                0x0B    #define BCTYPE_EAN13_2SUPPLEMENTALS                 0x4B    #define BCTYPE_MSI_PLESSEY                          0x0E    #define BCTYPE_EAN128                               0x0F    #define BCTYPE_UPCE1                                0x10    #define BCTYPE_UPCE1_2SUPPLEMENTALS                 0x50    #define BCTYPE_UPCE1_5SUPPLEMENTALS                 0x90    #define BCTYPE_CODE39_FULL_ASCII                    0x13    #define BCTYPE_TRIOPTIC_CODE39                      0x15    #define BCTYPE_BOOKLAND_EAN                         0x16    #define BCTYPE_COUPON_CODE                          0x17    #define BCTYPE_ISBT128                              0x19    #define BCTYPE_CODE32                               0x20Err NSB_SSMLibGetBarType(UInt16 refNum, UInt32 *barType){	// The barType returned from the decoder is sequential ordered, starting	// from 0.//	if( SysStringByIndex( BarTypesStringList, barType, pszBarType, nStrLen ) )//		return true;//	else//		return false;    Err retVal = 0;    MESSAGE msg;        WITHGLOBALS    retVal = SSMGetDecodedData(SSMLIBREFNUM, (UInt8 *) &msg);    *barType = msg.type;    ENDWITHGLOBALS    #if 0    // This does not work with an NSBasic program due to the resource file's not being present	switch (barType)	{		case BCTYPE_NOT_APPLICABLE: // 0x00			SysCopyStringResource( pszBarType, BCTypeNotApplicableString);			break;			case BCTYPE_CODE39: // 0x01			SysCopyStringResource( pszBarType, BCTypeCode39String);			break;			case BCTYPE_CODABAR: // 0x02			SysCopyStringResource( pszBarType, BCTypeCodabarString);			break;			case BCTYPE_CODE128: // 0x03			SysCopyStringResource( pszBarType, BCTypeCode128String);			break;			case BCTYPE_D2OF5: // 0x04			SysCopyStringResource( pszBarType, BCTypeDiscrete2Of5String);			break;			case BCTYPE_IATA2OF5: // 0x05			SysCopyStringResource( pszBarType, BCTypeIATA2of5String);			break;			case BCTYPE_I2OF5: // 0x06			SysCopyStringResource( pszBarType, BCTypeInterleaved2Of5String);			break;			case BCTYPE_CODE93: // 0x07			SysCopyStringResource( pszBarType, BCTypeCode93String);			break;			case BCTYPE_UPCA: // 0x08			SysCopyStringResource( pszBarType, BCTypeUPCAString);			break;			case BCTYPE_UPCE0: // 0x09			SysCopyStringResource( pszBarType, BCTypeUPCEOString);			break;			case BCTYPE_EAN8: // 0x0A			SysCopyStringResource( pszBarType, BCTypeEAN8String);			break;			case BCTYPE_EAN13: // 0x0B			SysCopyStringResource( pszBarType, BCTypeEAN13String);			break;			case BCTYPE_MSI_PLESSEY: // 0x0E			SysCopyStringResource( pszBarType, BCTypeMSIPlesseyString);			break;			case BCTYPE_EAN128: // 0x0F			SysCopyStringResource( pszBarType, BCTypeEAN128String);			break;			case BCTYPE_UPCE1:  // 0x10			SysCopyStringResource( pszBarType, BCTypeUPCE1String);			break;	//		case BCTYPE_CODE39_FULL_ASCII: // 0x13//			SysCopyStringResource( pszBarType, BCTypeNotApplicableString);//			break;			case BCTYPE_TRIOPTIC_CODE39: // 0x15			SysCopyStringResource( pszBarType, BCTypeTriopticCode39String);			break;			case BCTYPE_BOOKLAND_EAN: // 0x16			SysCopyStringResource( pszBarType, BCTypeBooklandEANString);			break;			case BCTYPE_COUPON_CODE: // 0x17			SysCopyStringResource( pszBarType, BCTypeCouponCodeString);			break;	//		case BCTYPE_ISBT128:   // 0x19//			SysCopyStringResource( pszBarType, BCTypeISBT128String);//			break;	//		case BCTYPE_CODE32: // 0x20//			SysCopyStringResource( pszBarType, BCTypeCode32String);//			break;			case BCTYPE_UPCA_2SUPPLEMENTALS: // 0x48			SysCopyStringResource( pszBarType, BCTypeUPCA2SuppsString);			break;			case BCTYPE_UPCE0_2SUPPLEMENTALS: // 0x49			SysCopyStringResource( pszBarType, BCTypeUPCEO2SuppsString);			break;			case BCTYPE_EAN8_2SUPPLEMENTALS:  // 0x4A			SysCopyStringResource( pszBarType, BCTypeEAN82SuppsString);			break;			case BCTYPE_EAN13_2SUPPLEMENTALS: // 0x4B			SysCopyStringResource( pszBarType, BCTypeEAN132SuppsString);			break;			case BCTYPE_UPCE1_2SUPPLEMENTALS: // 0x50			SysCopyStringResource( pszBarType, BCTypeUPCE12SuppsString);			break;			case BCTYPE_EAN8_5SUPPLEMENTALS:  // 0x8A			SysCopyStringResource( pszBarType, BCTypeEAN85SuppsString);			break;			case BCTYPE_EAN13_5SUPPLEMENTALS: // 0x8B			SysCopyStringResource( pszBarType, BCTypeEAN135SuppsString);			break;			case BCTYPE_UPCA_5SUPPLEMENTALS:  // 0x88			SysCopyStringResource( pszBarType, BCTypeUPCA5SuppsString);			break;			case BCTYPE_UPCE0_5SUPPLEMENTALS: // 0x89			SysCopyStringResource( pszBarType, BCTypeUPCEO5SuppsString);			break;			case BCTYPE_UPCE1_5SUPPLEMENTALS: // 0x90			SysCopyStringResource( pszBarType, BCTypeUPCE15SuppsString);			break;			default: 			StrCopy(pszBarType,"UNKNOWN");				break;	}#endif	return 0;}/** * Get the last scan data */Err NSB_SSMLibGetLastScanData(UInt16 refNum, UInt8 *buffer){    Err retVal;    MESSAGE msg;        WITHGLOBALS    retVal = SSMGetDecodedData(SSMLIBREFNUM, (UInt8 *) &msg);    ENDWITHGLOBALS        MemMove(buffer, msg.data, msg.length);    buffer[msg.length] = '\0';        return retVal;}/************************************************************ * *  FUNCTION: PrvMakeGlobals * *  DESCRIPTION:	Create our library globals. * *  PARAMETERS:	refNum		-- Sample library reference number * *  CALLED BY:		internal * *  RETURNS:		pointer to our *locked* library globals; NULL if our globals *						could not be created. * *  CREATED: 5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static NSB_SSMLibGlobalsPtr PrvMakeGlobals(UInt16 refNum){	NSB_SSMLibGlobalsPtr	gP = NULL;							// our globals pointer	MemHandle				gH;									// our globals handle	SysLibTblEntryPtr		libEntryP;							// pointer to our library table entry	// Get library globals	libEntryP = SysLibTblEntry(refNum);						// get our system library table entry	ErrFatalDisplayIf(libEntryP == NULL, "invalid Sample lib refNum");		// Error check to make sure the globals don't already exist	ErrFatalDisplayIf(libEntryP->globalsP, "Sample lib globals already exist");			// Allocate and initialize our library globals.	gH = MemHandleNew(sizeof(NSB_SSMLibGlobalsType));	if ( !gH )		return( NULL );											// memory allocation error		// Save the handle of our library globals in the system library table entry so we	// can later retrieve it using SysLibTblEntry().	libEntryP->globalsP = (void*)gH;	// Lock our globals	gP = PrvLockGlobals(refNum);				// this should not fail	ErrFatalDisplayIf(gP == NULL, "Failed to lock Sample lib globals");				// Set the owner of our globals memory chunk to "system" (zero), so it won't get	// freed automatically by Memory Manager when the first application to call	// SampleLibOpen exits.  This is important if the library is going to stay open	// between apps.	MemPtrSetOwner(gP, 0);		// Initialize our library globals	MemSet(gP, sizeof(NSB_SSMLibGlobalsType), 0);	gP->thisLibRefNum = refNum;		// for convenience and debugging (althouth not used in this sample library)	gP->openCount = 0;					// initial open count		return( gP );							// return a pointer to our *locked* globals}/************************************************************ * *  FUNCTION: PrvFreeGlobals * *  DESCRIPTION:	Free our library globals. * *  PARAMETERS:	refNum		-- Sample library reference number * *  CALLED BY:		internal * *  RETURNS:		nothing * *  CREATED: 5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static void PrvFreeGlobals(UInt16 refNum){	MemHandle					gH;									// our globals handle	SysLibTblEntryPtr		libEntryP;							// pointer to our library table entry	// Get our library globals handle	libEntryP = SysLibTblEntry(refNum);						// get our system library table entry	ErrFatalDisplayIf(libEntryP == NULL, "invalid Sample lib refNum");		gH = (MemHandle)(libEntryP->globalsP);					// get our globals handle from the entry		// Free our library globals	if ( gH )		{		libEntryP->globalsP = NULL;							// clear our globals reference		MemHandleFree(gH);										// free our globals		}}/************************************************************ * *  FUNCTION: PrvLockGlobals * *  DESCRIPTION:	Lock our library globals. * *  PARAMETERS:	refNum		-- Sample library reference number * *  CALLED BY:		internal * *  RETURNS:		pointer to our library globals; NULL if our globals *						have not been created yet. * *  CREATED: 5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static NSB_SSMLibGlobalsPtr PrvLockGlobals(UInt16 refNum){	NSB_SSMLibGlobalsPtr	gP = NULL;	MemHandle				gH;	SysLibTblEntryPtr		libEntryP;	libEntryP = SysLibTblEntry(refNum);						// get our system library table entry	if ( libEntryP )		gH = (MemHandle)(libEntryP->globalsP);				// get our globals handle from the entry	if ( gH )		gP = (NSB_SSMLibGlobalsPtr)MemHandleLock(gH);		// lock our globals	return( gP );}/************************************************************ * *  FUNCTION: PrvIsLibOpen * *  DESCRIPTION:	Check if the library has been opened. * *  PARAMETERS:	refNum		-- Sample library reference number * *  CALLED BY:		internal * *  RETURNS:		non-zero if the library has been opened * *  CREATED: 6/9/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static Boolean PrvIsLibOpen(UInt16 refNum){	NSB_SSMLibGlobalsPtr	gP;	Boolean	isOpen = false;		gP = PrvLockGlobals(refNum);		if ( gP )		{		isOpen = true;		PrvUnlockGlobals(gP);		}		return( isOpen );}/************************************************************ * *  FUNCTION: PrvCreateClientContext * *  DESCRIPTION:	Create a client context for storing client-specific data. *						The client context allows the library to support multiple clients. * *  PARAMETERS:	gP						-- pointer to our locked globals *						clientContextP		-- pointer to variable for returning client context * *  CALLED BY:		Anyone wishing to create a client context * *  RETURNS:		0						-- no error *						sampleErrNotOpen	-- the library is not open *						sampleErrMemory	-- insufficient memory * *						*clientContextP will be set to client context on success, or zero on error. * *  CREATED: 6/9/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static Err PrvCreateClientContext(NSB_SSMLibGlobalsPtr gP, UInt32 * clientContextP){	Err								err = 0;	MemHandle						contextH;	NSB_SSMLibClientContextPtr	contextP;		// Error-check our parameters	ErrFatalDisplayIf(gP == NULL, "null globals pointer");	ErrFatalDisplayIf(clientContextP == NULL, "Null context variable pointer");			// Initialize return variable	*clientContextP = 0;		// Allocate a new client context structure	contextH = MemHandleNew(sizeof(NSB_SSMLibClientContextType));	if ( !contextH )		{		err = sampleErrMemory;		}	else		{		*clientContextP = (UInt32)contextH;			// save context chunk handle in return variable				// Initialize the context chunk		contextP = (NSB_SSMLibClientContextPtr)MemHandleLock(contextH);		// lock context chunk		contextP->wSignature = sampleLibContextSignature;		// contextP->cornerDiam = sampleDefaultCornerDiameter;		PrvUnlockContext(contextP);													// unlock the context		gP->contextCount++;			// increment context count (for debugging)		ErrFatalDisplayIf(gP->contextCount == 0, "Context count overflow");		}	return( err );}/************************************************************ * *  FUNCTION: PrvDestroyClientContext * *  DESCRIPTION:	Destroy a client context which was created by PrvCreateClientContext. * *  PARAMETERS:	gP						-- pointer to our locked globals *						clientContext		-- client context * *  CALLED BY:		Anyone wishing to create a client context * *  RETURNS:		0						-- no error *						sampleErrNotOpen	-- the library is not open * *  CREATED: 6/9/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static Err PrvDestroyClientContext(NSB_SSMLibGlobalsPtr gP, UInt32 clientContext){	NSB_SSMLibClientContextPtr	contextP;		// Error-check our parameters	ErrFatalDisplayIf(gP == NULL, "Null globals pointer");	// Validate the client context by locking it	contextP = PrvLockContext(clientContext);		if ( contextP )		{		MemPtrFree(contextP);		// freeing a locked chunk is permitted by the system		gP->contextCount--;			// decrement context count (for debugging)		ErrFatalDisplayIf(gP->contextCount < 0, "context count underflow");		}		return( 0 );}/************************************************************ * *  FUNCTION: PrvLockContext * *  DESCRIPTION:	Validate and lock a client context. * *  PARAMETERS:	context		-- a client context to lock * *  CALLED BY:		internal * *  RETURNS:		pointer to the locked client context. * *  CREATED: 6/9/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static NSB_SSMLibClientContextPtr PrvLockContext(UInt32 context){	NSB_SSMLibClientContextPtr	contextP = NULL;			// Error-check our parameters	ErrFatalDisplayIf(context == 0, "Null client context");		// Lock the client context	contextP = (NSB_SSMLibClientContextPtr)MemHandleLock((MemHandle)context);	ErrFatalDisplayIf(contextP == NULL, "Failed to lock client context");	// should not happen		// Validate the client context	ErrFatalDisplayIf(contextP->wSignature != sampleLibContextSignature, "invalid client context");			return( contextP );}