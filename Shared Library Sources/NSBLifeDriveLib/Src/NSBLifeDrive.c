/****************************************************************************** * * File: NSBLifeDrive.C * Description: *      Library for NSBasic with LifeDrive devices * * History: *		5/31/02 Created by EMP * *****************************************************************************/#include <PalmOS.h>			// Includes all Palm OS headers#include <palmOne_68K.h>// Our library public definitions (library API)#define BUILDING_SAMPLE_LIB#include "NSBLifeDriveLib.h"// Our library private definitions (library globals, etc.)#include "NSBLifeDriveLibPrv.h"/******************************************************************** * LIBRARY GLOBALS: * * IMPORTANT: * ========== * Libraries are *not* allowed to have global or static variables.  Instead, * they allocate a memory chunk to hold their persistent data, and save * a handle to it in the library's system library table entry.  Example *	functions below demostrate how the library "globals" chunk is set up, saved, * and accessed. * * We use a movable memory chunk for our library globals to minimize * dynamic heap fragmentation.  Our library globals are locked only *	when needed and unlocked as soon as possible.  This behavior is * critical for healthy system performance. * ********************************************************************//******************************************************************** * Internally used data structures ********************************************************************//******************************************************************** * Internally used routines ********************************************************************/static NSBLifeDriveLibGlobalsPtr PrvMakeGlobals(UInt16 refNum);static void PrvFreeGlobals(UInt16 refNum);static NSBLifeDriveLibGlobalsPtr PrvLockGlobals(UInt16 refNum);static Boolean PrvIsLibOpen(UInt16 refNum);static Err PrvCreateClientContext(NSBLifeDriveLibGlobalsPtr gP, UInt32 * clientContextP);static Err PrvDestroyClientContext(NSBLifeDriveLibGlobalsPtr gP, UInt32 clientContext);static NSBLifeDriveLibClientContextPtr PrvLockContext(UInt32 context);/******************************************************************** * Internally used macros ********************************************************************/#define DORMANCY	(SysTicksPerSecond() / 2)// Unlock globals#define PrvUnlockGlobals(gP)	MemPtrUnlock(gP)// Unlock the client context#define PrvUnlockContext(contextP)	MemPtrUnlock(contextP)#define WITHGLOBALS {NSBLifeDriveLibGlobalsPtr gP = PrvLockGlobals(refNum);#define ENDWITHGLOBALS PrvUnlockGlobals(gP); }#define WITHCRYPTOGLOBALS {NSBLifeDriveLibGlobalsPtr gP = NULL; 	\	UInt16 refNum = FindRefNum(); 							\	if (refNum) {gP = PrvLockGlobals(refNum);} 		\	{#define ENDWITHCRYPTOGLOBALS } ENDWITHGLOBALS#define STACK1	0xE81CF00D	/* An unlikely constant */#define STACK2	0x74A1BEEF	/* Another unlikely constant */// LIBRARY VERSION//// The library version scheme follows the system versioning scheme.// See sysMakeROMVersion and friends in SystemMgr.h.//// For reference://// 0xMMmfsbbb, where MM is major version, m is minor version// f is bug fix, s is stage: 3-release,2-beta,1-alpha,0-development,// bbb is build number for non-releases // V1.12b3   would be: 0x01122003// V2.00a2   would be: 0x02001002// V1.01     would be: 0x01013000#define prvSampleLibVersion	sysMakeROMVersion(1, 0, 0, sysROMStageDevelopment, 1)static asm UInt16 FindRefNum(void){	move.l		a7,a0			// a0 -> stack	again:	move.w		(a0)+,d0first:	cmp.w		#0xE81C,d0	bne			againnext:	move.w		(a0)+,d0	cmp.w		#0xF00D,d0	bne			first		move.w		(a0)+,d0	cmp.w		#0x74A1,d0	bne			first		move.w		(a0)+,d0	cmp.w		#0xBEEF,d0	bne			first		move.l		#0,d0	move.w		(a0),d0		rts}/******************************************************************** * NSBLifeDrive Library API Routines ********************************************************************//************************************************************ * *  FUNCTION: NSBLifeDriveLibOpen * *  DESCRIPTION:	Opens the Sample library, creates and initializes the globals. *						This function must be called before any other Sample Library functions, *						with the exception of SampleLibGetLibAPIVersion. * *						If SampleLibOpen fails, do not call any other Sample library API functions. *						If SampleLibOpen succeeds, call SampleLibClose when you are done using *						the library to enable it to release critical system resources. * *  LIBRARY DEVELOPER NOTES: * *						The library's "open" and "close" functions should *not* take an excessive *						amount of time to complete.  If the processing time for either of these *						is lengthy, consider creating additional library API function(s) to handle *						the time-consuming chores. * * *  PARAMETERS:	refNum				-- Sample library reference number returned by SysLibLoad() *										   	   or SysLibFind(). * *  CALLED BY:		anyone who wants to use this library * *  RETURNS:		0							-- no error *						sampleErrMemory		-- not enough memory to initialize * *  CREATED:	5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/Err NSBLifeDriveLibOpen(UInt16 refNum){	NSBLifeDriveLibGlobalsPtr gP;	Err err = errNone;	Int16 originalOpenCount = 0;	UInt32 value;	// Get library globals	gP = PrvLockGlobals(refNum);										// lock our library globals		// Check if already open	if (!gP)		{		// Allocate and initialize our library globals.		gP = PrvMakeGlobals(refNum);									// returns locked globals on success		if ( !gP )			err = sampleErrMemory;		}	    gP->openCount++;		PrvUnlockGlobals(gP);											// unlock our library globals    WITHGLOBALS        gP -> browserPresent = false;    err = SysLibFind (kFileBrowserLibName, &(gP -> browserRefNum));    if (errNone == err)    {    	err = FileBrowserLibOpen(gP -> browserRefNum);    	if (errNone == err)    	{    		gP -> browserPresent = true;    	}    }        gP -> photoPresent = false;    gP -> depth = 0;	err = SysLibLoad (PalmPhotoLibTypeID, PalmPhotoLibCreatorID, &(gP -> photoRefNum));	if (errNone == err)	{		err = PalmPhotoLibOpen (gP -> photoRefNum);		if (errNone == err)		{			UInt32 width, height, depth;			Boolean enableColor;			gP -> photoPresent = true;			PalmPhotoLibGetVersion(gP -> photoRefNum, kPalmPhotoLibVersion3, &(gP -> photoVersion));				WinScreenMode(winScreenModeGet, &width, &height, &(gP -> depth), &enableColor);						WinScreenMode(winScreenModeGetSupportedDepths, &width, &height, &depth, &enableColor);			if (depth & 0x8000)			{				depth = 16;				WinScreenMode(winScreenModeSet, &width, &height, &depth, &enableColor);			}		}	}		gP -> vfsPresent = false;	if (0 == FtrGet(sysFileCVFSMgr, vfsFtrIDVersion, &value))	{		gP -> vfsPresent = true;	}		gP -> curSelected = false;	gP -> curSelection . userDataP = gP;	gP -> curSelection.selectedImages.imageCount = 0;	gP -> curSelection.selectedImages.imageH = NULL;	gP -> curSelection.filterCallback = NULL;    	ENDWITHGLOBALS	return(errNone);}/************************************************************ * *  FUNCTION: NSBLifeDriveLibClose * *  DESCRIPTION:	Closes the LifeDrive libary, frees globals. * *						***IMPORTANT*** *						May be called only if NSBLifeDriveLibOpen succeeded. * *						If other applications still have the library open, decrements *						the reference count and returns sampleErrStillOpen. * * *  LIBRARY DEVELOPER NOTES: * *						The library's "open" and "close" functions should *not* take an excessive *						amount of time to complete.  If the processing time for either of these *						is lengthy, consider creating additional library API function(s) to handle *						the time-consuming chores. *							 * *  PARAMETERS:	refNum				-- Sample library reference number returned by SysLibLoad() *												   or SysLibFind(). * *  CALLED BY:		Whoever wants to close the Sample library * *  RETURNS:		0							-- no error *						sampleErrStillOpen	-- library is still open by others (no error) * *  CREATED:	5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/Err NSBLifeDriveLibClose(UInt16 refNum){	Err						err = 0;		    /* Try to close the library */        WITHGLOBALS        if (gP -> browserPresent)    {		FileBrowserLibClose (gP -> browserRefNum);    }        if (gP -> photoPresent)    {    	if (gP -> depth)    	{			UInt32 width, height, depth;			Boolean enableColor;				WinScreenMode(winScreenModeGet, &width, &height, &depth, &enableColor);			depth = gP -> depth;			WinScreenMode(winScreenModeSet, &width, &height, &depth, &enableColor);    	}    		PalmPhotoLibClose (gP -> photoRefNum);		SysLibRemove(gP -> photoRefNum);    }        if (gP -> curSelected)    {		if (gP -> photoVersion >= kPalmPhotoLibVersion2)		{    		PalmPhotoFreeSelectionsV2(gP -> photoRefNum, &(gP -> curSelection));		}		else		{    		PalmPhotoFreeSelections(gP -> photoRefNum, &(gP -> curSelection));		}    }    	ENDWITHGLOBALS	return err;}/************************************************************ * *  FUNCTION: SampleLibSleep * *  DESCRIPTION:	Handles system sleep notification. * *						***IMPORTANT*** *						This notification function is called from a system interrupt. *						It is only allowed to use system services which are interrupt- *						safe.  Presently, this is limited to EvtEnqueueKey, SysDisableInts, *						SysRestoreStatus.  Because it is called from an interrupt, *						it must *not* take a long time to complete to preserve system *						integrity.  The intention is to allow system-level libraries *						to disable hardware components to conserve power while the system *						is asleep. * *  PARAMETERS:	refNum		-- Sample library reference number * *  CALLED BY:		System * *  RETURNS:		0						-- no error * *  CREATED:	5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/Err NSBLifeDriveLibSleep(UInt16 refNum){	return( 0 );}/************************************************************ * *  FUNCTION: SampleLibWake * *  DESCRIPTION:	Handles system wake notification * *						***IMPORTANT*** *						This notification function is called from a system interrupt. *						It is only allowed to use system services which are interrupt- *						safe.  Presently, this is limited to EvtEnqueueKey, SysDisableInts, *						SysRestoreStatus.  Because it is called from an interrupt, *						it must *not* take a long time to complete to preserve system *						integrity.  The intention is to allow system-level libraries *						to enable hardware components which were disabled when the system *						went to sleep. * *  PARAMETERS:	refNum		-- Sample library reference number * *  CALLED BY:	System * *  RETURNS:	0						-- no error * *  CREATED:	5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/Err NSBLifeDriveLibWake(UInt16 refNum){	return( 0 );}Err BrowserPresent(UInt16 refNum, UInt16 *ret){	WITHGLOBALS		*ret = gP -> browserPresent ? -1 : 0;		ENDWITHGLOBALS		return errNone;}Err BrowserOpenDialog(UInt16 refNum, UInt16 *volume, char *path, char *extend, char *title, UInt16 *ret){	UInt16 numExtensions;	char **extensions;	char *p;	UInt16 k;		WITHGLOBALS		*ret = 0;		if (!gP -> browserPresent) return errNone;		/* Count the extensions */	p = extend;	numExtensions = 1;	while (*p)	{		if (',' == *p) ++numExtensions;		++p;	}		p = extend;	extensions = (char **) MemPtrNew(sizeof(char *) * numExtensions);	for (k = 0; k < numExtensions; ++k)	{		char *r = p;		while (*r && *r != ',') ++r;		extensions[k] = (char *) MemPtrNew(r - p + 1);		MemMove(extensions[k], p, r - p);		extensions[k][r - p] = '\0';	}		// Display the Open dialog box. Returns whether a file was selected.	*ret = FileBrowserLibShowOpenDialog (gP -> browserRefNum, volume, path,		numExtensions , (const char **)extensions, // filter to show only these files		extensions[0], // use default folder for this fileType		title, // title for the dialog		kFileBrowserLibFlagNoFolders); // pick a file, not a folder	for (k = 0; k < numExtensions; ++k)	{		MemPtrFree(extensions[k]);	}	MemPtrFree(extensions);	ENDWITHGLOBALS	return errNone;}Err BrowserSaveDialog(UInt16 refNum, UInt16 *volume, char *path, char *extend, char *title, UInt16 *ret){	UInt16 numExtensions;	char **extensions;	char *p;	UInt16 k;		WITHGLOBALS		*ret = 0;		if (!gP -> browserPresent) return errNone;		/* Count the extensions */	p = extend;	numExtensions = 1;	while (*p)	{		if (',' == *p) ++numExtensions;		++p;	}		p = extend;	extensions = (char **) MemPtrNew(sizeof(char *) * numExtensions);	for (k = 0; k < numExtensions; ++k)	{		char *r = p;		while (*r && *r != ',') ++r;		extensions[k] = (char *) MemPtrNew(r - p + 1);		MemMove(extensions[k], p, r - p);		extensions[k][r - p] = '\0';	}		// Display the Save dialog box. Returns whether a file was selected.	*ret = FileBrowserLibShowSaveAsDialog (gP -> browserRefNum, volume, path,		numExtensions , (const char **)extensions, // filter to show only these files		extensions[0],		extensions[0], // use default folder for this fileType		title, // title for the dialog		kFileBrowserLibFlagPromptOverwrite);	for (k = 0; k < numExtensions; ++k)	{		MemPtrFree(extensions[k]);	}	MemPtrFree(extensions);	ENDWITHGLOBALS	return errNone;}Err PhotoPresent(UInt16 refNum, UInt16 *ret){	WITHGLOBALS		*ret = gP -> photoPresent ? -1 : 0;		ENDWITHGLOBALS	return errNone;}Err PhotoAlbumCount(UInt16 refNum, UInt16 vRefNum, UInt16 *ret){	WITHGLOBALS		if (gP -> photoPresent)	{		if (gP -> photoVersion >= kPalmPhotoLibVersion2)		{			*ret = PalmPhotoAlbumCountV2(gP -> photoRefNum, vRefNum);		}		else		{			*ret = PalmPhotoAlbumCount(gP -> photoRefNum);		}	}	else	{		*ret = 0;	}		ENDWITHGLOBALS	return errNone;}Err PhotoAlbumID(UInt16 refNum, UInt16 vRefNum, UInt16 index, UInt16 *ret){	WITHGLOBALS		if (gP -> photoPresent)	{		if (gP -> photoVersion >= kPalmPhotoLibVersion2)		{			*ret = PalmPhotoGetAlbumIDV2(gP -> photoRefNum, vRefNum, index - 1);		}		else		{			*ret = PalmPhotoGetAlbumID(gP -> photoRefNum, index - 1);		}	}		ENDWITHGLOBALS	return errNone;}Err PhotoAlbumName(UInt16 refNum, UInt16 ID, char *ret){	WITHGLOBALS		if (gP -> photoPresent)	{		PalmPhotoGetAlbumName(gP -> photoRefNum, ID, ret, 256);	}		ENDWITHGLOBALS		return errNone;}Err PhotoNewAlbum(UInt16 refNum, UInt16 vRefNum, char *name, UInt16 *ret){	WITHGLOBALS	if (gP -> photoPresent)	{		if (gP -> photoVersion >= kPalmPhotoLibVersion2)		{			*ret = PalmPhotoNewAlbumV2(gP -> photoRefNum, vRefNum, name);		}		else		{			Err err;			*ret = PalmPhotoNewAlbum(gP -> photoRefNum, name, &err);		}	};		ENDWITHGLOBALS	return errNone;}Err PhotoRenameAlbum(UInt16 refNum, UInt16 albumID, char *name, UInt16 *ret){	WITHGLOBALS	if (gP -> photoPresent)	{		*ret = PalmPhotoRenameAlbum(gP -> photoRefNum, albumID, name) ? 0 : -1;	};		ENDWITHGLOBALS	return errNone;}Err PhotoDeleteAlbum(UInt16 refNum, UInt16 albumID, UInt16 *ret){	WITHGLOBALS	if (gP -> photoPresent)	{		*ret = PalmPhotoDeleteAlbum(gP -> photoRefNum, albumID, true) ? 0 : -1;	};		ENDWITHGLOBALS	return errNone;}Err PhotoDeleteAlbumAndContents(UInt16 refNum, UInt16 albumID, UInt16 *ret){	WITHGLOBALS	if (gP -> photoPresent)	{		*ret = PalmPhotoDeleteAlbum(gP -> photoRefNum, albumID, false) ? 0 : -1;	};		ENDWITHGLOBALS	return errNone;}Err PhotoImageCount(UInt16 refNum, UInt16 albumID, UInt16 *ret){	WITHGLOBALS		if (gP -> photoPresent)	{		*ret = PalmPhotoImageCount(gP -> photoRefNum, albumID);	}	else	{		*ret = 0;	}		ENDWITHGLOBALS	return errNone;}Err PhotoSelectFromAlbum(UInt16 refNum, UInt16 albumID, UInt16 start, UInt16 number) {	WITHGLOBALS    if (gP -> curSelected)    {		if (gP -> photoVersion >= kPalmPhotoLibVersion2)		{    		PalmPhotoFreeSelectionsV2(gP -> photoRefNum, &(gP -> curSelection));		}		else		{    		PalmPhotoFreeSelections(gP -> photoRefNum, &(gP -> curSelection));		}    }        gP -> curSelection.albumID = albumID;    gP -> curSelection.offset = start - 1;    gP -> curSelection.selectionCount = number;        PalmPhotoSelectImages(gP -> photoRefNum, &(gP -> curSelection));        gP -> curSelected = true;        ENDWITHGLOBALS        return errNone;}Err PhotoSelectImage(UInt16 refNum){	WITHGLOBALS	  	if (gP -> curSelected)    {		if (gP -> photoVersion >= kPalmPhotoLibVersion2)		{    		PalmPhotoFreeSelectionsV2(gP -> photoRefNum, &(gP -> curSelection));		}		else		{    		PalmPhotoFreeSelections(gP -> photoRefNum, &(gP -> curSelection));		}    }        if (gP -> photoVersion >= kPalmPhotoLibVersion3)    {    	PalmPhotoSelectDlgV3(gP -> photoRefNum, &(gP -> curSelection), NULL,    		palmPhotoDlgSingleSelection, palmPhotoMediaTypePhoto, true);	}	else	{    	PalmPhotoSelectDlg(gP -> photoRefNum, &(gP -> curSelection), palmPhotoDlgSingleSelection, true);    }    gP -> curSelected = true;		ENDWITHGLOBALS		return errNone;}Err PhotoSelectImages(UInt16 refNum){	WITHGLOBALS	  	if (gP -> curSelected)    {		if (gP -> photoVersion >= kPalmPhotoLibVersion2)		{    		PalmPhotoFreeSelectionsV2(gP -> photoRefNum, &(gP -> curSelection));		}		else		{    		PalmPhotoFreeSelections(gP -> photoRefNum, &(gP -> curSelection));		}    }        if (gP -> photoVersion >= kPalmPhotoLibVersion3)    {    	PalmPhotoSelectDlgV3(gP -> photoRefNum, &(gP -> curSelection), NULL,    		palmPhotoDlgSelection, palmPhotoMediaTypePhoto, true);	}	else	{    	PalmPhotoSelectDlg(gP -> photoRefNum, &(gP -> curSelection), palmPhotoDlgSelection, true);    }    gP -> curSelected = true;		ENDWITHGLOBALS		return errNone;}Err PhotoSelectVideo(UInt16 refNum){	WITHGLOBALS	  	if (gP -> curSelected)    {		if (gP -> photoVersion >= kPalmPhotoLibVersion2)		{    		PalmPhotoFreeSelectionsV2(gP -> photoRefNum, &(gP -> curSelection));		}		else		{    		PalmPhotoFreeSelections(gP -> photoRefNum, &(gP -> curSelection));		}    }        if (gP -> photoVersion >= kPalmPhotoLibVersion3)    {    	PalmPhotoSelectDlgV3(gP -> photoRefNum, &(gP -> curSelection), NULL,    		palmPhotoDlgSingleSelection, palmPhotoMediaTypeVideo, true);	}	else	{    	PalmPhotoSelectDlg(gP -> photoRefNum, &(gP -> curSelection), palmPhotoDlgSingleSelection, true);    }    gP -> curSelected = true;		ENDWITHGLOBALS		return errNone;}Err PhotoSelectVideos(UInt16 refNum){	WITHGLOBALS	  	if (gP -> curSelected)    {		if (gP -> photoVersion >= kPalmPhotoLibVersion2)		{    		PalmPhotoFreeSelectionsV2(gP -> photoRefNum, &(gP -> curSelection));		}		else		{    		PalmPhotoFreeSelections(gP -> photoRefNum, &(gP -> curSelection));		}    }        if (gP -> photoVersion >= kPalmPhotoLibVersion3)    {    	PalmPhotoSelectDlgV3(gP -> photoRefNum, &(gP -> curSelection), NULL,    		palmPhotoDlgSelection, palmPhotoMediaTypeVideo, true);	}	else	{    	PalmPhotoSelectDlg(gP -> photoRefNum, &(gP -> curSelection), palmPhotoDlgSelection, true);    }    gP -> curSelected = true;		ENDWITHGLOBALS		return errNone;}Err PhotoSelectNone(UInt16 refNum){	WITHGLOBALS	  	if (gP -> curSelected)    {		if (gP -> photoVersion >= kPalmPhotoLibVersion2)		{    		PalmPhotoFreeSelectionsV2(gP -> photoRefNum, &(gP -> curSelection));		}		else		{    		PalmPhotoFreeSelections(gP -> photoRefNum, &(gP -> curSelection));		}    }    gP -> curSelected = false;	gP -> curSelection.selectedImages.imageCount = 0;	ENDWITHGLOBALS		return errNone;}Err PhotoSelectionCount(UInt16 refNum, UInt16 *ret){	WITHGLOBALS		*ret = gP -> curSelection.selectedImages.imageCount;		ENDWITHGLOBALS		return errNone;}Err PhotoSelectedImage(UInt16 refNum, UInt16 which, UInt32 *ret){	WITHGLOBALS	if (gP -> curSelected)	{		--which;				if (which > gP -> curSelection.selectedImages.imageCount)		{			*ret = 0;		}		else		{			*ret = (UInt32) (gP -> curSelection.selectedImages.imageH[which]);		}	}		ENDWITHGLOBALS		return errNone;}Boolean DisplayCallback(void *userData);Boolean DisplayCallback(void *userData){	return true;}static Err MemoryImageCallback(void *bufferP, UInt32 *sizeP, void *userDataP){	NSBLifeDriveLibGlobalsPtr gP = (NSBLifeDriveLibGlobalsPtr) userDataP;	//	MemMove(((char *)(gP -> createParam.fileLocation.file.MemoryFile.bufferP)) +//			gP -> createParam.fileLocation.file.MemoryFile.bufferSize, bufferP, *sizeP);	gP -> createParam.fileLocation.file.MemoryFile.bufferSize += *sizeP;			return errNone;}Err PhotoDisplayImage(UInt16 refNum, UInt32 imageH, UInt16 left, UInt16 top, UInt16 width, UInt16 height){	WITHGLOBALS	if (gP -> photoPresent)	{		Err err;		/* Display the image */		gP -> displayParams.rect.topLeft.x = left * 2;		gP -> displayParams.rect.topLeft.y = top * 2;		gP -> displayParams.rect.extent.x = width * 2;		gP -> displayParams.rect.extent.y = height * 2;		gP -> displayParams.displayCallback = DisplayCallback;		gP -> displayParams.userDataP = gP;		gP -> displayParams.winH = NULL;				err = PalmPhotoDisplayImage(gP -> photoRefNum, (PalmPhotoHandle) imageH, &(gP -> displayParams));	}		ENDWITHGLOBALS		return errNone;}Err PhotoImageName(UInt16 refNum, UInt32 imageH, char *ret){	WITHGLOBALS		if (gP -> photoPresent)	{		PalmPhotoFileLocation loc;		PalmPhotoExtraInfoParam extraInfo;		extraInfo.reserved = 0;		extraInfo.infoP = &loc;		extraInfo.infoSize = sizeof(loc);		extraInfo.infoType = palmPhotoExtraInfoLocation;		PalmPhotoGetImageExtraInfo(gP -> photoRefNum, (PalmPhotoHandle) imageH, &extraInfo);		if (palmPhotoVFSLocation == extraInfo.infoType)		{			StrCopy(ret, ((PalmPhotoFileLocation *)(extraInfo.infoP)) -> file.VFSFile.name);		}		else if (palmPhotoStreamLocation == extraInfo.infoType)		{			StrCopy(ret, ((PalmPhotoFileLocation *)(extraInfo.infoP)) -> file.StreamFile.name);		}	}		ENDWITHGLOBALS	return errNone;}#if 0Err VFSPresent(UInt16 refNum, UInt16 *ret){	WITHGLOBALS		*ret = gP -> vfsPresent ? -1 : 0;		ENDWITHGLOBALS		return errNone;}Err VFSCreate(UInt16 refNum, UInt16 volRefNum, char *pathName, UInt16 *ret){	Err err;		err = VFSFileCreate(volRefNum, pathName);	if (vfsErrFileAlreadyExists == err)	{		FileRef fileRef;				err = VFSFileOpen(volRefNum, pathName, vfsModeWrite, &fileRef);		if (errNone == err)		{			VFSFileResize(fileRef, 0);			VFSFileClose(fileRef);		}	}		*ret = (errNone == err) ? -1 : 0;	return errNone;}Err VFSOpen(UInt16 refNum, UInt16 volRefNum, char *pathName, UInt32 *ret){	if (errNone != VFSFileOpen(volRefNum, pathName, vfsModeReadWrite, (FileRef *)ret))	{		*ret = 0;	}		return errNone;}Err VFSClose(UInt16 refNum, UInt32 file){	if (file)		VFSFileClose(file);		return errNone;}Err VFSWriteString(UInt16 refNum, UInt32 file, char *string, UInt16 *ret){	if (file)	{		*ret = (errNone == VFSFileWrite((FileRef) file, StrLen(string) + 1, string, NULL)) ? 1 : 0;	}		return errNone;}Err VFSReadString(UInt16 refNum, UInt32 file, char *string, UInt16 *ret){	UInt32 filePos;	UInt32 n = 0;	char c;	Err err;	MemHandle m;	char *s;		VFSFileTell(file, &filePos);	do	{		++n;		err = VFSFileRead (file, 1, &c, NULL);	} while (err == errNone && '\0' != c);	    m = MemPtrRecoverHandle(string - sizeof(Char *));	MemHandleUnlock(m);	if (errNone == MemHandleResize(m,n))	{			s = MemHandleLock(m);		*((Char **) s) = s + sizeof(Char *);		s += sizeof(Char *);		VFSFileSeek(file, vfsOriginBeginning, filePos);		VFSFileRead(file, n, s, NULL);		s[n - 1] = '\0';		*ret = -1;	}	else	{		*ret = 0;	}		return errNone;}Err VFSWriteBytes(UInt16 refNum, UInt32 file, UInt32 n, char *string, UInt16 *ret){	if (file)	{		*ret = (errNone == VFSFileWrite((FileRef) file, n, string, NULL)) ? -1 : 0;	}	else	{		*ret = 0;	}	return errNone;}Err VFSReadBytes(UInt16 refNum, UInt32 file, UInt32 n, char *string, UInt16 *ret){	MemHandle m;	char *s;		    m = MemPtrRecoverHandle(string - sizeof(Char *));	MemHandleUnlock(m);	if (errNone == MemHandleResize(m,n))	{			s = MemHandleLock(m);		*((Char **) s) = s + sizeof(Char *);		s += sizeof(Char *);		*ret = (errNone == VFSFileRead(file, n, s, NULL)) ? -1 : 0;	}	else	{		*ret = 0;	}		return errNone;}Err VFSWriteInteger(UInt16 refNum, UInt32 file, UInt32 value, UInt16 *ret){	if (file)	{		*ret = (errNone == VFSFileWrite((FileRef) file, sizeof(value), &value, NULL)) ? 1 : 0;	}	else	{		*ret = 0;	}	return errNone;}Err VFSReadInteger(UInt16 refNum, UInt32 file, UInt32 *value, UInt16 *ret){	if (file)	{			*ret = (errNone == VFSFileRead(file, sizeof(*value), &value, NULL)) ? 1 : 0;	}	else	{		*ret = 0;	}		return errNone;}Err VFSWriteShort(UInt16 refNum, UInt32 file, UInt16 value, UInt16 *ret){	if (file)	{		*ret = (errNone == VFSFileWrite((FileRef) file, sizeof(value), &value, NULL)) ? 1 : 0;	}	else	{		*ret = 0;	}	return errNone;}Err VFSReadShort(UInt16 refNum, UInt32 file, UInt16 *value, UInt16 *ret){	if (file)	{			*ret = (errNone == VFSFileRead(file, sizeof(*value), &value, NULL)) ? 1 : 0;	}	else	{		*ret = 0;	}		return errNone;}Err VFSWriteFloat(UInt16 refNum, UInt32 file, double value, UInt16 *ret){	if (file)	{		*ret = (errNone == VFSFileWrite((FileRef) file, sizeof(value), &value, NULL)) ? 1 : 0;	}	else	{		*ret = 0;	}	return errNone;}Err VFSReadFloat(UInt16 refNum, UInt32 file, double *value, UInt16 *ret){	if (file)	{			*ret = (errNone == VFSFileRead(file, sizeof(*value), &value, NULL)) ? 1 : 0;	}	else	{		*ret = 0;	}		return errNone;}Err VFSWriteSingle(UInt16 refNum, UInt32 file, float value, UInt16 *ret){	if (file)	{		*ret = (errNone == VFSFileWrite((FileRef) file, sizeof(value), &value, NULL)) ? 1 : 0;	}	else	{		*ret = 0;	}	return errNone;}Err VFSReadSingle(UInt16 refNum, UInt32 file, float *value, UInt16 *ret){	if (file)	{			*ret = (errNone == VFSFileRead(file, sizeof(*value), &value, NULL)) ? 1 : 0;	}	else	{		*ret = 0;	}		return errNone;}Err VFSTell(UInt16 refNum, UInt32 file, UInt32 *ret){	if (file)	{		VFSFileTell(file, ret);	}	else	{		*ret = (UInt32) -1L;	}		return errNone;}Err VFSSeek(UInt16 refNum, UInt32 file, UInt32 pos, UInt16 *ret){	if (file)	{		VFSFileSeek(file, vfsOriginBeginning, pos);		*ret = 0;	}	else	{		*ret = 0;	}		return errNone;}Err VFSVolumeCount(UInt16 refNum, UInt16 *ret){	UInt32 iterator = vfsIteratorStart;	Err err;	UInt16 volRefNum;		*ret = 0;		do	{		++*ret;		err = VFSVolumeEnumerate(&volRefNum, &iterator);	} while (errNone == err && vfsInvalidVolRef != iterator);		--*ret;		return errNone;}Err VFSVolumeID(UInt16 refNum, UInt16 which, UInt16 *ret){	UInt16 k;	UInt32 iterator = vfsIteratorStart;		/* Which is 1-based */	for (k = 0; k < which; ++k)	{		VFSVolumeEnumerate(ret, &iterator);	}	return errNone;}Err VFSVolumeLabel(UInt16 refNum, UInt16 volRefNum, char *label){	Err err;    StrCopy(label, "Device");	err = VFSVolumeGetLabel(volRefNum, label, 299);		return errNone;}#endif#if 0Err MainNumber(UInt16 refNum, char *ret){	Err err = errNone;	PhnAddressHandle address;	PhnAddressList list;	WITHGLOBALS	if (PhnLibModulePowered(gP -> phoneLibRefNum))	{		err = PhnLibGetOwnNumbers(gP -> phoneLibRefNum, &list);		if (!err)		{			UInt32 phnType;			HsAttrGet(hsAttrPhoneType, 0, &phnType);			if (phnType == hsAttrPhoneTypeCDMA)			{				err = PhnLibAPGetNth(gP -> phoneLibRefNum, list, 1, &address);				if (!err)				{						if (address)					{	// Get the number						CharPtr number;						number = PhnLibAPGetField(gP -> phoneLibRefNum, address, phnAddrFldPhone);						if (number)						{							StrCopy(ret, number);							MemPtrFree(number);						}						else						{							StrCopy(ret, "ERROR: Number not found");						}						MemHandleFree(address);					}					else					{						StrCopy(ret, "ERROR: Number not found");					}				}			}			else			{				err = PhnLibGetNth(gP -> phoneLibRefNum, list, 1, &address);				if (!err)				{						if (address)					{	// Get the voice phone number						CharPtr number;						number = PhnLibGetField(gP -> phoneLibRefNum, address, phnAddrFldPhone);						if (number)						{							StrCopy(ret, number);							MemPtrFree(number);						}						else						{							StrCopy(ret, "ERROR: Number not found");						}						MemHandleFree(address);					}					else					{						StrCopy(ret, "ERROR: Number not found");					}				}			}			MemHandleFree(list);			}	}	else	{		StrCopy(ret, "ERROR: Phone not on");	}	ENDWITHGLOBALS	return errNone;}Err PhoneOn(UInt16 refNum, long *ret){	WITHGLOBALS	*ret = PhnLibModulePowered(gP -> phoneLibRefNum) ? -1 : 0;	ENDWITHGLOBALS	return errNone;}Err PhoneTurnOn(UInt16 refNum){	HsTurnRadioOn();	return errNone;}Err TCPIPDropConnection(UInt16 refNum){	HsNetworkDropConnection();	return errNone;}Err Vibrate(UInt16 refNum, long *count){	UInt16 vibrate = kIndicatorAlertAlert;	HsIndicatorState((UInt16) *count, kIndicatorTypeVibrator, &vibrate);	return errNone;}Err Blink(UInt16 refNum, long *count){	UInt16 blink = kIndicatorAlertAlert;	HsIndicatorState((UInt16) *count, kIndicatorTypeLed, &blink);	return errNone;}Err Roaming(UInt16 refNum, long *ret){	Err err;	PhnRoamStatus roamStatus;	WITHGLOBALS	err = PhnLibRoaming(gP -> phoneLibRefNum, &roamStatus);	if (errNone == err)	{		if (PhnRoamStatusOff == roamStatus)		{			*ret = 0;		}		else		{			*ret = -1;		}	}	else	{		*ret = 0;	}	ENDWITHGLOBALS	return errNone;}Err Software(UInt16 refNum, char *ret){	Err err;	err = HsGetVersionString(hsVerStrComplete, ret, NULL);	if (err != errNone) *ret = '\0';	return errNone;}Err Hardware(UInt16 refNum, char *ret){	Err err;	err = HsGetVersionString(hsVerStrHardware, ret, NULL);	if (err != errNone) *ret = '\0';	return errNone;}Err ProductName(UInt16 refNum, char *ret){	Err err;	err = HsGetVersionString(hsVerStrProductName, ret, NULL);	if (err != errNone) *ret = '\0';	return errNone;}Err SerialNumber(UInt16 refNum, char *ret){	Err err;	err = HsGetVersionString(hsVerStrSerialNo, ret, NULL);	if (err != errNone) *ret = '\0';	return errNone;}Err CarrierID(UInt16 refNum, char *ret){	Err err;	err = HsGetVersionString(hsVerStrCarrierID, ret, NULL);	if (err != errNone) *ret = '\0';	return errNone;}Err ProductRevision(UInt16 refNum, char *ret){	Err err;	err = HsGetVersionString(hsVerStrCarrierID, ret, NULL);	if (err != errNone) *ret = '\0';	return errNone;}Err ROM(UInt16 refNum, char *ret){	Err err;	err = HsGetVersionString(hsVerStrROMBuild, ret, NULL);	if (err != errNone) *ret = '\0';	return errNone;}Err Firmware(UInt16 refNum, char *ret){	Err err;	err = HsGetVersionString(hsVerStrFirmwareVer, ret, NULL);	if (err != errNone) *ret = '\0';	return errNone;}Err NetworkAvailable(UInt16 refNum, long *ret){	WITHGLOBALS		if (PhnLibModulePowered(gP -> phoneLibRefNum))	{		*ret = PhnLibNetworkAvailable(gP -> phoneLibRefNum) ? -1 : 0;	}	else	{		*ret = 0;	}	ENDWITHGLOBALS	return errNone;}Err SignalQuality(UInt16 refNum, long *ret){	Err err;	UInt16 quality;		WITHGLOBALS	err = PhnLibSignalQuality (gP -> phoneLibRefNum, &quality);	if (!err)	{		*ret = quality;	}	ENDWITHGLOBALS	return err;}Err PhoneType(UInt16 refNum, char *ret){	UInt32 phnType = hsAttrPhoneTypeGSM; 	HsAttrGet(hsAttrPhoneType, 0, &phnType);	if (phnType == hsAttrPhoneTypeGSM)	{		StrCopy(ret, "GSM");	}	else	{		StrCopy(ret, "CDMA");	}		return errNone;}  Err PhoneReady(UInt16 refNum, long *ret){		WITHGLOBALS	// Make sure that the phone is powered...	if (PhnLibModulePowered(gP -> phoneLibRefNum))	{		UInt32 phnType = 0;		HsAttrGet(hsAttrPhoneType, 0, &phnType);				//Check if radio has initiliazed the SIM on GSM phone		if (PhnLibGetSIMStatus(gP -> phoneLibRefNum) != simReady &&			phnType == hsAttrPhoneTypeGSM)		{			*ret = 0;		}		else		{			if (PhnLibRegistered(gP -> phoneLibRefNum))				*ret = -1;			else				*ret = 0;		}	}	else	{		*ret = 0;	}	ENDWITHGLOBALS		return errNone;}Err BookCount(UInt16 refNum, long *ret){	Err err = errNone;		WITHGLOBALS	UInt32 phnType;	HsAttrGet(hsAttrPhoneType, 0, &phnType);	if (phnType == hsAttrPhoneTypeCDMA)	{		err = errNone;		*ret = 0;	}	else	{		if (NULL == gP -> list)		{			PhnPhoneBookInfoType info;			err = PhnLibGetPhoneBook(gP -> phoneLibRefNum, &(gP -> list), &info);		}		if (errNone == err)		{			UInt16 count;			err = PhnLibCount(gP -> phoneLibRefNum, gP -> list, &count);			if (errNone == err)			{				*ret = count;			}			else			{				*ret = 0;			}		}		else		{			*ret = 0;		}	}	ENDWITHGLOBALS		return errNone;}Err BookFirstName(UInt16 refNum, long idx, char *ret){	Err err = errNone;	PhnAddressHandle address;	Int16 which = idx;		WITHGLOBALS	if (NULL == gP -> list)	{		PhnPhoneBookInfoType info;		err = PhnLibGetPhoneBook(gP -> phoneLibRefNum, &(gP -> list), &info);	}	if (errNone == err)	{		UInt16 count;		err = PhnLibCount(gP -> phoneLibRefNum, gP -> list, &count);		if (errNone == err && which >= 0 && which < count)		{			UInt32 phnType;			HsAttrGet(hsAttrPhoneType, 0, &phnType);			if (phnType == hsAttrPhoneTypeCDMA)			{				err = PhnLibAPGetNth(gP -> phoneLibRefNum, gP -> list, which, &address);				if (!err)				{						if (address)					{	// Get the number						CharPtr number;						number = PhnLibAPGetField(gP -> phoneLibRefNum, address, phnAddrFldFirstName);						if (number)						{							StrCopy(ret, number);							MemPtrFree(number);						}						else						{							StrCopy(ret, "ERROR: Name not found");						}						MemHandleFree(address);					}					else					{						StrCopy(ret, "ERROR: Name not found");					}				}			}			else			{				err = PhnLibGetNth(gP -> phoneLibRefNum, gP -> list, which, &address);				if (!err)				{						if (address)					{	// Get the voice phone number						CharPtr number;						number = PhnLibGetField(gP -> phoneLibRefNum, address, phnAddrFldFirstName);						if (number)						{							StrCopy(ret, number);							MemPtrFree(number);						}						else						{							StrCopy(ret, "ERROR: Name not found");						}						MemHandleFree(address);					}					else					{						StrCopy(ret, "ERROR: Name not found");					}				}			}				}		else		{			*ret = 0;		}	}	else	{		*ret = 0;	}	ENDWITHGLOBALS		return errNone;}Err BookLastName(UInt16 refNum, long idx, char *ret){	Err err = errNone;	PhnAddressHandle address;	Int16 which = idx;		WITHGLOBALS	if (NULL == gP -> list)	{		PhnPhoneBookInfoType info;		err = PhnLibGetPhoneBook(gP -> phoneLibRefNum, &(gP -> list), &info);	}	if (errNone == err)	{		UInt16 count;		err = PhnLibCount(gP -> phoneLibRefNum, gP -> list, &count);		if (errNone == err && which >= 0 && which < count)		{			UInt32 phnType;			HsAttrGet(hsAttrPhoneType, 0, &phnType);			if (phnType == hsAttrPhoneTypeCDMA)			{				err = PhnLibAPGetNth(gP -> phoneLibRefNum, gP -> list, which, &address);				if (!err)				{						if (address)					{	// Get the number						CharPtr number;						number = PhnLibAPGetField(gP -> phoneLibRefNum, address, phnAddrFldLastName);						if (number)						{							StrCopy(ret, number);							MemPtrFree(number);						}						else						{							StrCopy(ret, "ERROR: Name not found");						}						MemHandleFree(address);					}					else					{						StrCopy(ret, "ERROR: Name not found");					}				}			}			else			{				err = PhnLibGetNth(gP -> phoneLibRefNum, gP -> list, which, &address);				if (!err)				{						if (address)					{	// Get the voice phone number						CharPtr number;						number = PhnLibGetField(gP -> phoneLibRefNum, address, phnAddrFldLastName);						if (number)						{							StrCopy(ret, number);							MemPtrFree(number);						}						else						{							StrCopy(ret, "ERROR: Name not found");						}						MemHandleFree(address);					}					else					{						StrCopy(ret, "ERROR: Name not found");					}				}			}				}		else		{			*ret = 0;		}	}	else	{		*ret = 0;	}	ENDWITHGLOBALS		return errNone;}Err BookPhoneNumber(UInt16 refNum, long idx, char *ret){	Err err = errNone;	PhnAddressHandle address;	Int16 which = idx;		WITHGLOBALS	if (NULL == gP -> list)	{		PhnPhoneBookInfoType info;		err = PhnLibGetPhoneBook(gP -> phoneLibRefNum, &(gP -> list), &info);	}	if (errNone == err)	{		UInt16 count;		err = PhnLibCount(gP -> phoneLibRefNum, gP -> list, &count);		if (errNone == err && which >= 0 && which < count)		{			UInt32 phnType;			HsAttrGet(hsAttrPhoneType, 0, &phnType);			if (phnType == hsAttrPhoneTypeCDMA)			{				err = PhnLibAPGetNth(gP -> phoneLibRefNum, gP -> list, which, &address);				if (!err)				{						if (address)					{	// Get the number						CharPtr number;						number = PhnLibAPGetField(gP -> phoneLibRefNum, address, phnAddrFldPhone);						if (number)						{							StrCopy(ret, number);							MemPtrFree(number);						}						else						{							StrCopy(ret, "ERROR: Number not found");						}						MemHandleFree(address);					}					else					{						StrCopy(ret, "ERROR: Number not found");					}				}			}			else			{				err = PhnLibGetNth(gP -> phoneLibRefNum, gP -> list, which, &address);				if (!err)				{						if (address)					{	// Get the voice phone number						CharPtr number;						number = PhnLibGetField(gP -> phoneLibRefNum, address, phnAddrFldPhone);						if (number)						{							StrCopy(ret, number);							MemPtrFree(number);						}						else						{							StrCopy(ret, "ERROR: Number not found");						}						MemHandleFree(address);					}					else					{						StrCopy(ret, "ERROR: Number not found");					}				}			}				}		else		{			*ret = 0;		}	}	else	{		*ret = 0;	}	ENDWITHGLOBALS		return errNone;}Err BookReload(UInt16 refNum){	WITHGLOBALS	if (NULL != gP -> list)	{		MemHandleFree(gP -> list);		gP -> list = NULL;	}	ENDWITHGLOBALS	return errNone;}Err Provider(UInt16 refNum, char *ret){	Err err = errNone;	PhnOperatorID ID;	char *str;	GSMRegistrationMode mode;		WITHGLOBALS	err = PhnLibCurrentProvider(gP -> phoneLibRefNum, &str);	if (errNone == err)	{		if (*str)		{			StrCopy(ret, str);		}		else		{			err = PhnLibCurrentOperator(gP -> phoneLibRefNum, &ID, &str, &mode);			if (errNone == err)			{				StrCopy(ret, str);			}			else			{				StrCopy(ret, "ERROR: No current provider");			}		}	}	else	{		err = PhnLibCurrentOperator(gP -> phoneLibRefNum, &ID, &str, &mode);		if (errNone == err)		{			StrCopy(ret, str);		}		else		{			StrCopy(ret, "ERROR: No current provider");		}	}	ENDWITHGLOBALS			return errNone;}Err OperatorCurName(UInt16 refNum, char *ret){	Err err;	PhnOperatorID ID;	char *str;	GSMRegistrationMode mode;		WITHGLOBALS	err = PhnLibCurrentOperator(gP -> phoneLibRefNum, &ID, &str, &mode);	if (errNone == err)	{		StrCopy(ret, str);	}	else	{		StrCopy(ret, "ERROR: No current operator");	}	ENDWITHGLOBALS	return errNone;}Err OperatorCurID(UInt16 refNum, char *ret){	Err err;	Int16 size = 299;		WITHGLOBALS	err = PhnLibCurrentOperatorID (gP -> phoneLibRefNum, ret,		&size);	if (errNone != err)	{		StrCopy(ret, "ERROR: No current operator");	}	ENDWITHGLOBALS		return errNone;}Err OperatorCount(UInt16 refNum, long *ret){	Err err;	PhnOperatorListPtr list;		WITHGLOBALS	err = PhnLibGetOperatorList(gP -> phoneLibRefNum, &list);	if (errNone == err)	{		*ret = list -> count;	}	else	{		*ret = 0;	}	ENDWITHGLOBALS		return errNone;}Err OperatorName(UInt16 refNum, long idx, char *ret){	Err err;	PhnOperatorListPtr list;	Int16 which = idx;		WITHGLOBALS	err = PhnLibGetOperatorList(gP -> phoneLibRefNum, &list);	if (errNone == err)	{		which = which - 1;		if (which >= 0 && which < list -> count)		{			if (list -> opData[which].longname[0])			{				StrCopy(ret, list -> opData[which].longname);			}			else			{				StrCopy(ret, list -> opData[which].shortname);			}		}		else		{			*ret = '\0';		}	}	else	{		*ret = 0;	}	ENDWITHGLOBALS		return errNone;} Err Operator(UInt16 refNum, long idx, long type){	Err err;	PhnOperatorListPtr list;	Int16 which = idx;		WITHGLOBALS	err = PhnLibGetOperatorList(gP -> phoneLibRefNum, &list);	if (errNone == err)	{		which = which - 1;		if (which >= 0 && which < list -> count)		{			err = PhnLibSetOperator(gP -> phoneLibRefNum,				&(list -> opData[which]), type);		}	}	ENDWITHGLOBALS		return err;}Err DialPhone(UInt16 refNum, char *number){	char buf[1];	buf[0] = '\0';	HsOpenDialNumberDialog(number, buf, true);	return errNone;}Err SendEMail(UInt16 refNum, char *addr, char *cc, char *subj, char *msg){	HsCreateNewEmail(addr, cc, subj, msg);	return errNone;}Err SendSMSMessage(UInt16 refNum, char *nbr, char *name, char *msg){	HsCreateNewMessage(nbr, name, msg);	return errNone;}Err Browse(UInt16 refNum, char *URL){	HsBrowseUrl(URL);	return errNone;}Err CallWaitingSet(UInt16 refNum, long whether){	Err err;	WITHGLOBALS	err = PhnLibSetCallWaiting(gP -> phoneLibRefNum, whether ? true : false);	ENDWITHGLOBALS	return err;}Err CallWaiting(UInt16 refNum, long *ret){	Err err;	Boolean whether = false;	WITHGLOBALS	err = PhnLibGetCallWaiting(gP -> phoneLibRefNum,&whether);	*ret = whether ? -1 : 0;	ENDWITHGLOBALS	return errNone;}Err KeyboardLocked(UInt16 refNum, long *ret){	UInt32 value = 0;	Err err = HsAttrGet(hsAttrKeyboardLocked, 0, &value);	*ret = value ? -1 : 0;	return errNone;}Err KeyboardLock(UInt16 refNum, long inVal){	UInt32 value = inVal ? 1 : 0;	Err err = HsAttrSet(hsAttrKeyboardLocked, 0, &value);	return err;}/* HTTP code *//* callbacks */static Int32 PrvTCPOpen(Int32 in_domain, HS_HTTPLibOpaque in_aux){	NetSocketRef	sockRef;	Err 					error;	UInt16				 flag;	UInt16					sizeFlag = sizeof(flag);	Int16 				ret;	NetSocketLingerType lin;		WITHCRYPTOGLOBALS	sockRef = NetLibSocketOpen(gP -> appNetLibNum, netSocketAddrINET,netSocketTypeStream,netSocketProtoIPTCP, TCP_TIMEOUT, &error);	flag = 1;	/* set to non-blocking socket */	ret = NetLibSocketOptionSet(gP -> appNetLibNum, sockRef, netSocketOptLevelSocket,netSocketOptSockNonBlocking, &flag, sizeFlag, TCP_TIMEOUT, &error);	lin.onOff = true;	lin.time = 0;	/* set linger */	ret = NetLibSocketOptionSet(gP -> appNetLibNum, sockRef, netSocketOptLevelSocket,netSocketOptSockLinger, &lin, sizeof(lin),TCP_TIMEOUT, &error);	/* netSocketAddrRaw : netSocketAddrINET */	/* netSocketTypeDatagram : netSocketTypeRaw : netSocketTypeReliableMsg */	/* netSocketIPTCP : netSocketIPUDP : netSocketIPRAW */	if (error){		NetLibSocketClose(gP -> appNetLibNum, sockRef,20000/*timeout*/, &error);		sockRef = httpErrorGeneric;	}	ENDWITHCRYPTOGLOBALS		return sockRef;}static void PrvTCPClose(Int32 in_desc, HS_HTTPLibOpaque in_aux){	Int16  result;	Int32 timeout = TCP_TIMEOUT;	Err 	 error = 0;	if(in_desc == -1) return;	WITHCRYPTOGLOBALS	result = NetLibSocketClose(gP -> appNetLibNum, (NetSocketRef)in_desc,timeout, &error);	ENDWITHCRYPTOGLOBALS}static Int32 PrvTCPIsConnected(Int32 in_desc, HS_HTTPLibOpaque in_aux){	NetFDSetType	fds, wfds, dummy;	Err 					error;	long					timeout = TCP_TIMEOUT;	Int16 				ret;	UInt16					width;	width = in_desc + 1;	netFDZero(&fds);	netFDSet((NetSocketRef)in_desc, &fds);	netFDZero(&wfds);	netFDSet((NetSocketRef)in_desc, &wfds);	netFDZero(&dummy);	WITHCRYPTOGLOBALS	ret = NetLibSelect(gP -> appNetLibNum, width, &fds, &wfds, &dummy,timeout, &error);	ENDWITHCRYPTOGLOBALS	return ret;}static Int32 PrvTCPConnect(Int32 in_desc, HS_HTTPLibIPAddr *in_addr, Int32 in_port, HS_HTTPLibOpaque in_aux){	Err 								 error;	NetSocketAddrINType  sockAddr;	Int32 							timeout = TCP_TIMEOUT;	Int16 							 result;	Int16 							 addrlen = sizeof(sockAddr);	/* Address setup */	MemSet(&sockAddr, addrlen, 0);		sockAddr.family = netSocketAddrINET;	sockAddr.port = (UInt16)NetHToNS((UInt16)in_port);	{			Char*  src;			Int16 index = 0;			/* memcpy */			for (src = (Char*)in_addr->addr; index < 4; index++)				*((Char*)&sockAddr.addr + index) = *(src + index);	}	/*	sockAddr.addr = PALM_NetLibAddrAToIN((Char*)in_addr); */	/* connect */	WITHCRYPTOGLOBALS	result = NetLibSocketConnect(gP -> appNetLibNum, (Int16)in_desc,(NetSocketAddrType*)&sockAddr, addrlen,timeout, &error);	ENDWITHCRYPTOGLOBALS	if (result == -1) {		/* error */		switch (error) {		case netErrSocketAlreadyConnected:			result = httpErrorOK;		break;		case netErrSocketBusy:		case netErrWouldBlock:			result = httpErrorWouldBlock;		break;		default:			result = httpErrorGeneric;		break;		}	} else {		result = httpErrorOK;	}	return result;}static Int32 PrvTCPRead(Int32 in_desc, Char *out_buf, Int32 in_len, HS_HTTPLibOpaque in_aux){	Int16 	 result;	Int32 	 timeout = TCP_TIMEOUT;	UInt16		 flg = 0;	Err 		 error;	Int32 ret = 0x0000ffff;	if (in_len > READ_CHUNK) {		in_len = READ_CHUNK;	}	WITHCRYPTOGLOBALS	result = NetLibReceive(gP -> appNetLibNum, (NetSocketRef)in_desc,out_buf, (UInt16)in_len,flg, NULL, NULL, timeout, &error);	ENDWITHCRYPTOGLOBALS	if (result == -1){		switch (error) {		case netErrSocketBusy:		case netErrSocketNotConnected:		case netErrWouldBlock:			result = httpErrorWouldBlock;		break;		default:			result = httpErrorGeneric;		break;		}	} else {		ret &= result;		return ret;	}	return result;	}static Int32 PrvTCPWrite(Int32 in_desc, Char *in_buf, Int32 in_len, HS_HTTPLibOpaque in_aux){	Int16  result;	Int32  timeout = 5*SysTicksPerSecond();	UInt16	 flg = 0;	Err 	 error;	if (in_len > READ_CHUNK) {		in_len = READ_CHUNK;	}	WITHCRYPTOGLOBALS	result = NetLibSend(gP -> appNetLibNum, (NetSocketRef)in_desc, in_buf, (UInt16)in_len,0, 0, flg, timeout, &error);	ENDWITHCRYPTOGLOBALS	if (result == -1) {		switch (error) {		case netErrSocketBusy:		case netErrSocketNotConnected:		case netErrWouldBlock:			result = httpErrorWouldBlock;		break;		default:			result = httpErrorGeneric;		break;		}	} else {    	// DIKEO debug_text(in_buf, in_len);	}	return result;}static Int32 PrvTCPCanReadWrite(Int32 in_desc, Int32 in_rw, HS_HTTPLibOpaque in_aux){	NetFDSetType	fds, wfds, dummy;	Err 					error;	long					timeout = TCP_TIMEOUT;	Int16 				selected;	UInt16					width;	Int32 ret;	width = in_desc + 1;	netFDZero(&fds);	netFDSet((NetSocketRef)in_desc, &fds);	WITHCRYPTOGLOBALS	switch (in_rw) {	case httpStreamRead:		selected = NetLibSelect(gP -> appNetLibNum, width, &fds, NULL, &dummy,timeout, &error);			if (selected != 1){				ret = selected;			}else{				ret = httpStreamRead;			}	break;	case httpStreamWrite:		selected = NetLibSelect(gP -> appNetLibNum, width, NULL, &fds, &dummy,timeout, &error);		if (selected <=0){			ret = selected;		} else if (selected == 2){			ret = httpStreamReadWrite;		} else {			ret = httpStreamWrite;		}	break;	default:		netFDZero(&wfds);		netFDSet((NetSocketRef)in_desc, &wfds);		selected = NetLibSelect(gP -> appNetLibNum, width, &fds, &wfds, &dummy,timeout, &error);		if (selected <=0){			ret =  selected;		} else if (selected == 2){			ret = httpStreamReadWrite;		} else if (netFDIsSet((NetSocketRef)in_desc, &fds)){			ret = httpStreamRead;		}else{			ret = httpStreamWrite;		}	break;	}	ENDWITHCRYPTOGLOBALS	return ret;}static UInt16 get_instance(NSBLifeDriveLibGlobalsPtr gP){	Err err;	UInt16 index,ifInstance;	UInt32 ifCreator;	UInt16 ret = 0xffff;	for(index = 0;1;index++){		err = NetLibIFGet(gP -> appNetLibNum, index, &ifCreator, &ifInstance);		if(err) break;		if(ifCreator == netIFCreatorPPP){			ret = ifInstance;			break;		}	}	return ret;}static Err ifup(NSBLifeDriveLibGlobalsPtr gP){	UInt16 ifInstance;	Err err = -1;	UInt16 ifErrs;	Err retVal = -1;		if(gP -> isNetLibOpen == false){   		err = NetLibOpen(gP -> appNetLibNum, &ifErrs);        if (err || ifErrs) {            NetLibClose(gP -> appNetLibNum, true);           	err = -1;           	goto retErr;        }    	gP -> isNetLibOpen = true;	}	ifInstance = get_instance(gP);	if(ifInstance != 0xffff){		err = NetLibIFUp(gP -> appNetLibNum, netIFCreatorPPP,ifInstance);		if (!err) gP -> isNetLibUp = true;		}retErr:;	return err;}static Err ifdown(NSBLifeDriveLibGlobalsPtr gP){	Err err = 0;	UInt16 ifInstance;		ifInstance = get_instance(gP);	if(ifInstance != 0xffff){		if (gP -> isNetLibUp) {			gP -> isNetLibUp = false;			//			err = NetLibClose(gP -> appNetLibNum, true);			err = NetLibIFDown(gP -> appNetLibNum, netIFCreatorPPP, ifInstance,-1);		}		}	else	{		err = -1;	}	return err;}static ErrPrvPeerInitialize(void){	Err err = -1;		WITHCRYPTOGLOBALS	gP -> isNetLibOpen = false;	err = SysLibFind("Net.lib", &(gP -> appNetLibNum));		if (gP -> appNetLibNum){		err = ifup(gP);	}else{		err = -1;	}	if(!err){		gP -> PPPConnectF = true;	}	else	{		gP -> PPPConnectF = false;	}	ENDWITHCRYPTOGLOBALS	return err;}static Err PrvPeerFinalize(NSBLifeDriveLibGlobalsPtr gP){	Err err = 0;	if (gP -> appNetLibNum){		err = ifdown(gP);	}	gP -> PPPConnectF = false;	return err;}static Err GlueHTTPOpen(UInt32 stack1, UInt32 stack2, UInt16 refNum){    Err err = errNone;    WITHGLOBALS    /* load the library */	if( gP -> HTTPRefNum == sysInvalidRefNum ) {		err = SysLibFind(HS_HTTPLibName, &(gP -> HTTPRefNum));	    if (err) {	        err = SysLibLoad(HS_HTTPLibDBType, HS_HTTPLibID, &(gP -> HTTPRefNum));		}	}	gP -> fHTTPStream = NULL;	ENDWITHGLOBALS	if (errNone != err)	{		return err;	}		WITHGLOBALS	err = HS_HTTPLibOpen(gP -> HTTPRefNum);	if (err)	{			}	// DIKEO check error	/* gPeer */	gP -> HTTPPeer = (HS_HTTPLibPeer *)MemPtrNew(sizeof(HS_HTTPLibPeer));		MemSet(gP -> HTTPPeer, 0, sizeof(HS_HTTPLibPeer));	gP -> HTTPPeer -> HS_HTTPLibPeerTCPOpen = &PrvTCPOpen;	gP -> HTTPPeer -> HS_HTTPLibPeerTCPClose = &PrvTCPClose;	gP -> HTTPPeer -> HS_HTTPLibPeerTCPIsConnected = &PrvTCPIsConnected;	gP -> HTTPPeer -> HS_HTTPLibPeerTCPConnect = &PrvTCPConnect;	gP -> HTTPPeer -> HS_HTTPLibPeerTCPRead = &PrvTCPRead;	gP -> HTTPPeer -> HS_HTTPLibPeerTCPWrite = &PrvTCPWrite;	gP -> HTTPPeer -> HS_HTTPLibPeerTCPCanReadWrite = &PrvTCPCanReadWrite;	gP -> appInfo = (HS_HTTPLibAppInfo *)MemPtrNew(sizeof(HS_HTTPLibAppInfo));	MemSet(gP -> appInfo, 0, sizeof(HS_HTTPLibAppInfo));	gP -> appInfo -> maxSockets = 3;	gP -> appInfo -> isForeground = true;	gP -> appInfo -> cookieMaxJarSize = (UInt16)300 * (UInt16)1024;	gP -> appInfo -> cookieDBName = NULL;	gP -> netLibInfo = (HS_HTTPLibNetLibInfo *)MemPtrNew(sizeof(HS_HTTPLibNetLibInfo));	MemSet(gP -> netLibInfo, 0, sizeof(HS_HTTPLibNetLibInfo));	err = PrvPeerInitialize();	if (err)	{		// DIKEO return error	}	SysTaskDelay(SysTicksPerSecond());	gP -> libHandle = HS_HTTPLibInitialize(gP -> HTTPRefNum, gP -> appInfo, gP -> netLibInfo, gP -> HTTPPeer);	if (!gP -> libHandle)	{		// DIKEO return error	}		/* set callbacks */	//HS_HTTPLibSetSSLServerCertConfirmProc(gP -> HTTPRefNum, gLibHandle, &test_confirm_cb, (HS_HTTPLibOpaque)gLibHandle);	//HS_HTTPLibSetTunnelingCallback(gP -> HTTPRefNum, gLibHandle, &PrvTunnelingCallback, NULL);		/* set timeout time */	HS_HTTPLibSetConnectTimeOut(gP -> HTTPRefNum, gP -> libHandle, -1);	HS_HTTPLibSetReqTimeOut(gP -> HTTPRefNum, gP -> libHandle, -1);	HS_HTTPLibSetRspTimeOut(gP -> HTTPRefNum, gP -> libHandle, 10 * 1000);		/* set proxy info */	//HS_HTTPLibSetProxy(gP -> HTTPRefNum, gLibHandle, ProxyHost, StrLen(ProxyHost), ProxyPort, ProxyPort, NoProxyHost, 0);	//HS_HTTPLibSetUseProxy(gP -> HTTPRefNum, gLibHandle, true);	ENDWITHGLOBALSdone:		return err;}Err HTTPOpen(UInt16 refNum, long *ret){	Err err = GlueHTTPOpen(STACK1, STACK2, refNum);	*ret = err ? 0 : -1;	return errNone;}static Err GlueHTTPClose(UInt32 stack1, UInt32 stack2, UInt16 refNum){	Err err;	UInt16 count;		WITHGLOBALS	if (gP -> fHTTPStream)	{			HS_HTTPLibStreamClose(gP -> HTTPRefNum, gP->fHTTPStream );	/* Close HTTP */			HS_HTTPLibStreamDelete(gP -> HTTPRefNum, gP->fHTTPStream );			gP->fHTTPStream = NULL;	}	HS_HTTPLibFinalize(gP -> HTTPRefNum, gP -> libHandle);	PrvPeerFinalize(gP);	gP -> libHandle = NULL;		err = HS_HTTPLibClose(gP -> HTTPRefNum, &count);	gP -> isNetLibOpen = false;	gP -> isNetLibUp = false;		/* unload the library */	if( gP -> HTTPRefNum != sysInvalidRefNum ){		SysLibRemove(gP -> HTTPRefNum);		gP -> HTTPRefNum = sysInvalidRefNum;	}	//MemPtrFree(gP -> appInfo -> cookieDBName);	//MemPtrFree(gP -> appInfo -> certDBName);	MemPtrFree(gP -> appInfo);	MemPtrFree(gP -> netLibInfo);	MemPtrFree(gP -> HTTPPeer);	gP -> appInfo = NULL;	gP -> netLibInfo = NULL;	gP -> HTTPPeer = NULL;	ENDWITHGLOBALS	return err;}Err HTTPClose(UInt16 refNum){	return GlueHTTPClose(STACK1, STACK2, refNum);}static Err GlueHTTPSendRequest(UInt32 stack1, UInt32 stack2, UInt16 refNum, char *url, long timeInMs){	Err err = errNone;	Int32 result;	Int32 k;	UInt32 ticks;	UInt32 delta;		WITHGLOBALS	gP -> requestPending = true;	gP -> fHTTPStream = HS_HTTPLibStreamNew(gP -> HTTPRefNum, gP -> libHandle);	if(!gP -> fHTTPStream)	{		err = -1;	}	else	{			result = HS_HTTPLibStreamCreateRequest(gP -> HTTPRefNum,  gP -> fHTTPStream, httpMethodGET, 				url, StrLen(url), "", 0, "", 0, 				httpVersion_1_1, false, false, httpSSLFlagConnV2V3TLS);		HS_HTTPLibStreamAddHeader(gP -> HTTPRefNum, gP -> fHTTPStream, httpHeaderIDAcceptEncoding, "*/*", 3);			ticks = TimGetTicks();		k = 0;		while (delta = TimGetTicks() - ticks,			   delta = (delta << 3) + (delta << 2),			   delta < timeInMs)		{			++k;			result = HS_HTTPLibStreamSendRequest(gP -> HTTPRefNum, gP -> fHTTPStream, NULL);			if(result == httpErrorOK)			{				err = errNone;				break;			}else if(result == httpErrorWouldBlock){			}			else			{				err = httpErrorWouldBlock;				break;			}			SysTaskDelay(DORMANCY);			if (err)			{				HS_HTTPLibStreamClose(gP -> HTTPRefNum, gP->fHTTPStream );	/* Close HTTP */				HS_HTTPLibStreamDelete(gP -> HTTPRefNum, gP->fHTTPStream );				gP->fHTTPStream = NULL;			}		}	}	ENDWITHGLOBALS		return err;}static Err GlueHTTPEnd(UInt32 stack1, UInt32 stack2, UInt16 refNum){	WITHGLOBALS	if (gP -> fHTTPStream)	{		HS_HTTPLibStreamClose(gP -> HTTPRefNum, gP->fHTTPStream);	/* Close HTTP */		HS_HTTPLibStreamDelete(gP -> HTTPRefNum, gP->fHTTPStream);		gP->fHTTPStream = NULL;	}	ENDWITHGLOBALS	return errNone;}Err HTTPEnd(UInt16 refNum){	GlueHTTPEnd(STACK1, STACK2, refNum);	return errNone;}Err HTTPSendRequest(UInt16 refNum, char *url, long timeInMs, long *ret){	Err err = GlueHTTPSendRequest(STACK1, STACK2, refNum, url, timeInMs);	*ret = err ? 0 : -1;	return errNone;}static Err GlueHTTPSendPostRequest(UInt32 stack1, UInt32 stack2, UInt16 refNum, char *url, char *postData, long timeInMs){	Err err = errNone;	Int32 result;	Int32 k;	UInt32 ticks;	UInt32 delta;		WITHGLOBALS	gP -> requestPending = true;	gP -> fHTTPStream = HS_HTTPLibStreamNew(gP -> HTTPRefNum, gP -> libHandle);	if(!gP -> fHTTPStream)	{		err = -1;	}	else	{			result = HS_HTTPLibStreamCreateRequest(gP -> HTTPRefNum,  gP -> fHTTPStream, httpMethodPOST, 				url, StrLen(url), "", 0, "", 0, 				httpVersion_1_1, false, false, httpSSLFlagConnV2V3TLS);		HS_HTTPLibStreamSetPostData(gP -> HTTPRefNum, gP -> fHTTPStream, httpPostURLENCODED, postData, StrLen(postData));		//HS_HTTPLibStreamAddHeader(gP -> HTTPRefNum, gP -> fHTTPStream, httpHeaderIDAcceptEncoding, "*/*", 3);			ticks = TimGetTicks();		k = 0;		while (delta = TimGetTicks() - ticks,			   delta = (delta << 3) + (delta << 2),			   delta < timeInMs)		{			++k;			result = HS_HTTPLibStreamSendRequest(gP -> HTTPRefNum, gP -> fHTTPStream, NULL);			if(result == httpErrorOK)			{				err = errNone;				break;			}else if(result == httpErrorWouldBlock){			}			else			{				err = httpErrorWouldBlock;				break;			}			SysTaskDelay(DORMANCY);		}				if (err)		{			HS_HTTPLibStreamClose(gP -> HTTPRefNum, gP->fHTTPStream );	/* Close HTTP */			HS_HTTPLibStreamDelete(gP -> HTTPRefNum, gP->fHTTPStream );			gP->fHTTPStream = NULL;		}	}	ENDWITHGLOBALS		return err;}Err HTTPSendPostRequest(UInt16 refNum, char *url, char *postData, long timeInMs, long *ret){	Err err = GlueHTTPSendRequest(STACK1, STACK2, refNum, url, timeInMs);	*ret = err ? 0 : -1;	return errNone;}static Err GlueHTTPGetHeader(UInt32 stack1, UInt32 stack2, UInt16 refNum, Int32 *lenIn, HS_HTTPLibVHandle *handle, UInt32 timeInMs){	Int32 result;	Int32 len=0;	Err err = -1;	HS_HTTPLibVHandle hdrH = NULL;	UInt32 contentLength;		Int32 k;	UInt32 ticks;	UInt32 delta;		k = 0;	*lenIn = 0;	WITHGLOBALS	ticks = TimGetTicks();	while (delta = TimGetTicks() - ticks,		   delta = (delta << 3) + (delta << 2),		   delta < timeInMs)	{		result = HS_HTTPLibStreamReceiveResponse(gP -> HTTPRefNum, gP -> fHTTPStream, NULL, 0, &len, NULL);		hdrH = HS_HTTPLibStreamGetResponseHeader(gP -> HTTPRefNum, gP -> fHTTPStream);		switch(result){		case httpErrorOK:		case httpErrorWouldBlock:			if(HS_HTTPLibStreamIsHeaderReceived(gP -> HTTPRefNum, gP -> fHTTPStream)){				contentLength = HS_HTTPLibStreamGetContentLength(gP -> HTTPRefNum, gP -> fHTTPStream);				*handle = hdrH;				*lenIn = HS_HTTPLibStreamGetResponseHeaderLength(gP -> HTTPRefNum, gP -> fHTTPStream);				err = errNone;				goto exit;			}			else			{				Int32	hLen;				hLen = HS_HTTPLibStreamGetResponseHeaderLength(gP -> HTTPRefNum, gP -> fHTTPStream);			}		break;		default:			break;		break;		}		SysTaskDelay(DORMANCY);	}exit:;	ENDWITHGLOBALS	return errNone;}Err HTTPGetHeader(UInt16 refNum, long timeInMs, char *ret){	HS_HTTPLibVHandle hdrH = NULL;	Int32 lenIn;	Err err = errNone;	WITHGLOBALS	err = GlueHTTPGetHeader(STACK1, STACK2, refNum, &lenIn, &hdrH, timeInMs);	if (errNone == err)	{		if (hdrH)		{			Char *p;			MemPtr *d;			MemHandle h = MemPtrRecoverHandle(((char *)ret) - sizeof(MemHandle));						MemHandleUnlock(h);			MemHandleResize(h, lenIn + 1 + sizeof(MemPtr));			d = ((MemPtr *)MemHandleLock(h));			*d = d + 1;						p = (Char *)HS_HTTPLibVHandle_Lock(gP -> HTTPRefNum, hdrH);			MemMove(d + 1, p, lenIn);			((char *)(d + 1))[lenIn] = '\0';			HS_HTTPLibVHandle_Unlock(gP -> HTTPRefNum, hdrH);		}		else		{			StrCopy(ret, "");		}	}	else	{		StrCopy(ret, "");	}	ENDWITHGLOBALS	return errNone;}static Err GlueHTTPRead(UInt32 stack1, UInt32 stack2, UInt16 refNum, long size, Int32 *lenIn, char *ret, UInt32 timeInMs){	Int32 len=0;	Err err = -1;	HS_HTTPLibVHandle hdrH = NULL;	UInt32 remainingLength = size;	UInt32 offset = 0;		Int32 k;	UInt32 ticks;	UInt32 delta;		k = 0;	*lenIn = 0;	WITHGLOBALS	if (gP -> requestPending)	{		ticks = TimGetTicks();		while (delta = TimGetTicks() - ticks,			   delta = (delta << 3) + (delta << 2),			   delta < timeInMs)		{			err = HS_HTTPLibStreamReceiveResponse(gP -> HTTPRefNum, gP -> fHTTPStream, 							ret + offset, size - offset, &len, NULL);														switch(err){			case httpErrorOK:			case httpErrorWouldBlock:			case httpErrorIOSleep:				if(len > 0){					offset += len;				}								if (offset >= size || httpErrorOK == err)				{					/* Return with this done */					*lenIn = offset;					if (httpErrorOK == err)					{						gP -> requestPending = false;					}					goto exit;				}						break;			default:				break;			break;			}			SysTaskDelay(DORMANCY);		}	}	else	{		*ret = '\0';		err = httpErrorOK;	}exit:;	ENDWITHGLOBALS	return err;}Err HTTPRead(UInt16 refNum, long size, long timeInMs, char *ret){	Int32 lenIn = 0;	Err err = errNone;	MemPtr *d;	MemHandle h;	long locSize;		locSize = size + 1;	if (locSize < 300) locSize = 300;	h = MemPtrRecoverHandle(((char *)ret) - sizeof(MemHandle));		MemHandleUnlock(h);	MemHandleResize(h, locSize + sizeof(MemPtr));	d = ((MemPtr *)MemHandleLock(h));	*d = d + 1;	WITHGLOBALS	err = GlueHTTPRead(STACK1, STACK2, refNum, size, &lenIn, ret, timeInMs);	if (errNone == err ||		httpErrorOK == err ||		httpErrorWouldBlock == err ||		httpErrorIOSleep == err)	{		ret[lenIn] = '\0';	}	else	{		StrCopy(ret, "ERROR: Read error");	}	ENDWITHGLOBALS	return errNone;}#endif/************************************************************ * *  FUNCTION: PrvMakeGlobals * *  DESCRIPTION:	Create our library globals. * *  PARAMETERS:	refNum		-- Sample library reference number * *  CALLED BY:		internal * *  RETURNS:		pointer to our *locked* library globals; NULL if our globals *						could not be created. * *  CREATED: 5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static NSBLifeDriveLibGlobalsPtr PrvMakeGlobals(UInt16 refNum){	NSBLifeDriveLibGlobalsPtr	gP = NULL;							// our globals pointer	MemHandle				gH;									// our globals handle	SysLibTblEntryPtr		libEntryP;							// pointer to our library table entry	// Get library globals	libEntryP = SysLibTblEntry(refNum);						// get our system library table entry	ErrFatalDisplayIf(libEntryP == NULL, "invalid Sample lib refNum");		// Error check to make sure the globals don't already exist	ErrFatalDisplayIf(libEntryP->globalsP, "Sample lib globals already exist");			// Allocate and initialize our library globals.	gH = MemHandleNew(sizeof(NSBLifeDriveLibGlobalsType));	if ( !gH )		return( NULL );											// memory allocation error		// Save the handle of our library globals in the system library table entry so we	// can later retrieve it using SysLibTblEntry().	libEntryP->globalsP = (void*)gH;	// Lock our globals	gP = PrvLockGlobals(refNum);				// this should not fail	ErrFatalDisplayIf(gP == NULL, "Failed to lock Sample lib globals");				// Set the owner of our globals memory chunk to "system" (zero), so it won't get	// freed automatically by Memory Manager when the first application to call	// SampleLibOpen exits.  This is important if the library is going to stay open	// between apps.	MemPtrSetOwner(gP, 0);		// Initialize our library globals	MemSet(gP, sizeof(NSBLifeDriveLibGlobalsType), 0);	gP->thisLibRefNum = refNum;		// for convenience and debugging (althouth not used in this sample library)	gP->openCount = 0;					// initial open count		return( gP );							// return a pointer to our *locked* globals}/************************************************************ * *  FUNCTION: PrvFreeGlobals * *  DESCRIPTION:	Free our library globals. * *  PARAMETERS:	refNum		-- Sample library reference number * *  CALLED BY:		internal * *  RETURNS:		nothing * *  CREATED: 5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static void PrvFreeGlobals(UInt16 refNum){	MemHandle					gH;									// our globals handle	SysLibTblEntryPtr		libEntryP;							// pointer to our library table entry	// Get our library globals handle	libEntryP = SysLibTblEntry(refNum);						// get our system library table entry	ErrFatalDisplayIf(libEntryP == NULL, "invalid Sample lib refNum");		gH = (MemHandle)(libEntryP->globalsP);					// get our globals handle from the entry		// Free our library globals	if ( gH )		{		libEntryP->globalsP = NULL;							// clear our globals reference		MemHandleFree(gH);										// free our globals		}}/************************************************************ * *  FUNCTION: PrvLockGlobals * *  DESCRIPTION:	Lock our library globals. * *  PARAMETERS:	refNum		-- Sample library reference number * *  CALLED BY:		internal * *  RETURNS:		pointer to our library globals; NULL if our globals *						have not been created yet. * *  CREATED: 5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static NSBLifeDriveLibGlobalsPtr PrvLockGlobals(UInt16 refNum){	NSBLifeDriveLibGlobalsPtr	gP = NULL;	MemHandle				gH;	SysLibTblEntryPtr		libEntryP;	libEntryP = SysLibTblEntry(refNum);						// get our system library table entry	if ( libEntryP )		gH = (MemHandle)(libEntryP->globalsP);				// get our globals handle from the entry	if ( gH )		gP = (NSBLifeDriveLibGlobalsPtr)MemHandleLock(gH);		// lock our globals	return( gP );}/************************************************************ * *  FUNCTION: PrvIsLibOpen * *  DESCRIPTION:	Check if the library has been opened. * *  PARAMETERS:	refNum		-- Sample library reference number * *  CALLED BY:		internal * *  RETURNS:		non-zero if the library has been opened * *  CREATED: 6/9/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static Boolean PrvIsLibOpen(UInt16 refNum){	NSBLifeDriveLibGlobalsPtr	gP;	Boolean	isOpen = false;		gP = PrvLockGlobals(refNum);		if ( gP )		{		isOpen = true;		PrvUnlockGlobals(gP);		}		return( isOpen );}/************************************************************ * *  FUNCTION: PrvCreateClientContext * *  DESCRIPTION:	Create a client context for storing client-specific data. *						The client context allows the library to support multiple clients. * *  PARAMETERS:	gP						-- pointer to our locked globals *						clientContextP		-- pointer to variable for returning client context * *  CALLED BY:		Anyone wishing to create a client context * *  RETURNS:		0						-- no error *						sampleErrNotOpen	-- the library is not open *						sampleErrMemory	-- insufficient memory * *						*clientContextP will be set to client context on success, or zero on error. * *  CREATED: 6/9/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static Err PrvCreateClientContext(NSBLifeDriveLibGlobalsPtr gP, UInt32 * clientContextP){	Err								err = 0;	MemHandle						contextH;	NSBLifeDriveLibClientContextPtr	contextP;		// Error-check our parameters	ErrFatalDisplayIf(gP == NULL, "null globals pointer");	ErrFatalDisplayIf(clientContextP == NULL, "Null context variable pointer");			// Initialize return variable	*clientContextP = 0;		// Allocate a new client context structure	contextH = MemHandleNew(sizeof(NSBLifeDriveLibClientContextType));	if ( !contextH )		{		err = sampleErrMemory;		}	else		{		*clientContextP = (UInt32)contextH;			// save context chunk handle in return variable				// Initialize the context chunk		contextP = (NSBLifeDriveLibClientContextPtr)MemHandleLock(contextH);		// lock context chunk		contextP->wSignature = sampleLibContextSignature;		// contextP->cornerDiam = sampleDefaultCornerDiameter;		PrvUnlockContext(contextP);													// unlock the context		gP->contextCount++;			// increment context count (for debugging)		ErrFatalDisplayIf(gP->contextCount == 0, "Context count overflow");		}	return( err );}/************************************************************ * *  FUNCTION: PrvDestroyClientContext * *  DESCRIPTION:	Destroy a client context which was created by PrvCreateClientContext. * *  PARAMETERS:	gP						-- pointer to our locked globals *						clientContext		-- client context * *  CALLED BY:		Anyone wishing to create a client context * *  RETURNS:		0						-- no error *						sampleErrNotOpen	-- the library is not open * *  CREATED: 6/9/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static Err PrvDestroyClientContext(NSBLifeDriveLibGlobalsPtr gP, UInt32 clientContext){	NSBLifeDriveLibClientContextPtr	contextP;		// Error-check our parameters	ErrFatalDisplayIf(gP == NULL, "Null globals pointer");	// Validate the client context by locking it	contextP = PrvLockContext(clientContext);		if ( contextP )		{		MemPtrFree(contextP);		// freeing a locked chunk is permitted by the system		gP->contextCount--;			// decrement context count (for debugging)		ErrFatalDisplayIf(gP->contextCount < 0, "context count underflow");		}		return( 0 );}/************************************************************ * *  FUNCTION: PrvLockContext * *  DESCRIPTION:	Validate and lock a client context. * *  PARAMETERS:	context		-- a client context to lock * *  CALLED BY:		internal * *  RETURNS:		pointer to the locked client context. * *  CREATED: 6/9/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static NSBLifeDriveLibClientContextPtr PrvLockContext(UInt32 context){	NSBLifeDriveLibClientContextPtr	contextP = NULL;			// Error-check our parameters	ErrFatalDisplayIf(context == 0, "Null client context");		// Lock the client context	contextP = (NSBLifeDriveLibClientContextPtr)MemHandleLock((MemHandle)context);	ErrFatalDisplayIf(contextP == NULL, "Failed to lock client context");	// should not happen		// Validate the client context	ErrFatalDisplayIf(contextP->wSignature != sampleLibContextSignature, "invalid client context");			return( contextP );}