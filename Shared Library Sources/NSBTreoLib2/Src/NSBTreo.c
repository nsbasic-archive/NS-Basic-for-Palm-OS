/****************************************************************************** * * File: NSBTreo.C * Description: *      Library for NSBasic with Treo devices * * History: *		5/22/01 Created by EMP * *****************************************************************************/#include <PalmOS.h>			// Includes all Palm OS headers#include <Rect.h>				// for RectangleType#include <Window.h>			// for WinDrawRectangle// Our library public definitions (library API)#define BUILDING_SAMPLE_LIB#include "NSBTreoLib.h"// Our library private definitions (library globals, etc.)#include "NSBTreoLibPrv.h"/******************************************************************** * LIBRARY GLOBALS: * * IMPORTANT: * ========== * Libraries are *not* allowed to have global or static variables.  Instead, * they allocate a memory chunk to hold their persistent data, and save * a handle to it in the library's system library table entry.  Example *	functions below demostrate how the library "globals" chunk is set up, saved, * and accessed. * * We use a movable memory chunk for our library globals to minimize * dynamic heap fragmentation.  Our library globals are locked only *	when needed and unlocked as soon as possible.  This behavior is * critical for healthy system performance. * ********************************************************************//******************************************************************** * Internally used data structures ********************************************************************//******************************************************************** * Internally used routines ********************************************************************/static NSBTreoLibGlobalsPtr PrvMakeGlobals(UInt16 refNum);static void PrvFreeGlobals(UInt16 refNum);static NSBTreoLibGlobalsPtr PrvLockGlobals(UInt16 refNum);static Boolean PrvIsLibOpen(UInt16 refNum);static Err PrvCreateClientContext(NSBTreoLibGlobalsPtr gP, UInt32 * clientContextP);static Err PrvDestroyClientContext(NSBTreoLibGlobalsPtr gP, UInt32 clientContext);static NSBTreoLibClientContextPtr PrvLockContext(UInt32 context);/******************************************************************** * Internally used macros ********************************************************************/#define DORMANCY	(SysTicksPerSecond() / 2)// Unlock globals#define PrvUnlockGlobals(gP)	MemPtrUnlock(gP)// Unlock the client context#define PrvUnlockContext(contextP)	MemPtrUnlock(contextP)#define WITHGLOBALS {NSBTreoLibGlobalsPtr gP = PrvLockGlobals(refNum);#define ENDWITHGLOBALS PrvUnlockGlobals(gP); }#define WITHCRYPTOGLOBALS {NSBTreoLibGlobalsPtr gP = NULL; 	\	UInt16 refNum = FindRefNum(); 							\	if (refNum) {gP = PrvLockGlobals(refNum);} 		\	{#define ENDWITHCRYPTOGLOBALS } ENDWITHGLOBALS#define TCP_TIMEOUT 	 (SysTicksPerSecond()/2)  /* return immediately, we'll poll */#define READ_CHUNK 65535#define STACK1	0xE81CF00D	/* An unlikely constant */#define STACK2	0x74A1BEEF	/* Another unlikely constant */// LIBRARY VERSION//// The library version scheme follows the system versioning scheme.// See sysMakeROMVersion and friends in SystemMgr.h.//// For reference://// 0xMMmfsbbb, where MM is major version, m is minor version// f is bug fix, s is stage: 3-release,2-beta,1-alpha,0-development,// bbb is build number for non-releases // V1.12b3   would be: 0x01122003// V2.00a2   would be: 0x02001002// V1.01     would be: 0x01013000#define prvSampleLibVersion	sysMakeROMVersion(1, 0, 0, sysROMStageDevelopment, 1)static asm UInt16 FindRefNum(void){	move.l		a7,a0			// a0 -> stack	again:	move.w		(a0)+,d0first:	cmp.w		#0xE81C,d0	bne			againnext:	move.w		(a0)+,d0	cmp.w		#0xF00D,d0	bne			first		move.w		(a0)+,d0	cmp.w		#0x74A1,d0	bne			first		move.w		(a0)+,d0	cmp.w		#0xBEEF,d0	bne			first		move.l		#0,d0	move.w		(a0),d0		rts}/******************************************************************** * NSBTreo Library API Routines ********************************************************************//************************************************************ * *  FUNCTION: NSBTreoLibOpen * *  DESCRIPTION:	Opens the Sample library, creates and initializes the globals. *						This function must be called before any other Sample Library functions, *						with the exception of SampleLibGetLibAPIVersion. * *						If SampleLibOpen fails, do not call any other Sample library API functions. *						If SampleLibOpen succeeds, call SampleLibClose when you are done using *						the library to enable it to release critical system resources. * *  LIBRARY DEVELOPER NOTES: * *						The library's "open" and "close" functions should *not* take an excessive *						amount of time to complete.  If the processing time for either of these *						is lengthy, consider creating additional library API function(s) to handle *						the time-consuming chores. * * *  PARAMETERS:	refNum				-- Sample library reference number returned by SysLibLoad() *										   	   or SysLibFind(). * *  CALLED BY:		anyone who wants to use this library * *  RETURNS:		0							-- no error *						sampleErrMemory		-- not enough memory to initialize * *  CREATED:	5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/Err NSBTreoLibOpen(UInt16 refNum){	NSBTreoLibGlobalsPtr gP;	Err err = errNone;	Int16 originalOpenCount = 0;    	// Get library globals	gP = PrvLockGlobals(refNum);										// lock our library globals		// Check if already open	if (!gP)		{		// Allocate and initialize our library globals.		gP = PrvMakeGlobals(refNum);									// returns locked globals on success		if ( !gP )			err = sampleErrMemory;		}	    gP->openCount++;		PrvUnlockGlobals(gP);											// unlock our library globals    WITHGLOBALS    gP -> HTTPRefNum = sysInvalidRefNum;	gP -> isNetLibOpen = false;	gP -> isNetLibUp = false;	gP -> requestPending = false;    if (errNone == err)    {	    	    /* Try to open the TREO library */		err = HsGetPhoneLibrary(&(gP -> phoneLibRefNum));	}	gP -> list = NULL;	ENDWITHGLOBALS	return( err );}/************************************************************ * *  FUNCTION: NSBTreoLibClose * *  DESCRIPTION:	Closes the Sample libary, frees globals. * *						***IMPORTANT*** *						May be called only if SampleLibOpen succeeded. * *						If other applications still have the library open, decrements *						the reference count and returns sampleErrStillOpen. * * *  LIBRARY DEVELOPER NOTES: * *						The library's "open" and "close" functions should *not* take an excessive *						amount of time to complete.  If the processing time for either of these *						is lengthy, consider creating additional library API function(s) to handle *						the time-consuming chores. *							 * *  PARAMETERS:	refNum				-- Sample library reference number returned by SysLibLoad() *												   or SysLibFind(). * *  CALLED BY:		Whoever wants to close the Sample library * *  RETURNS:		0							-- no error *						sampleErrStillOpen	-- library is still open by others (no error) * *  CREATED:	5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/Err NSBTreoLibClose(UInt16 refNum){	Err						err = 0;		    /* Try to close the library */        WITHGLOBALS    if (NULL != gP -> list)    {		MemHandleFree(gP -> list);    }    PhnLibClose(gP -> phoneLibRefNum);#if 0	if ((TelClose(gP -> telRefNum, gP -> telAppID)!= telErrLibStillInUse))		SysLibRemove(gP -> telRefNum);#endif	ENDWITHGLOBALS	return err;}/************************************************************ * *  FUNCTION: SampleLibSleep * *  DESCRIPTION:	Handles system sleep notification. * *						***IMPORTANT*** *						This notification function is called from a system interrupt. *						It is only allowed to use system services which are interrupt- *						safe.  Presently, this is limited to EvtEnqueueKey, SysDisableInts, *						SysRestoreStatus.  Because it is called from an interrupt, *						it must *not* take a long time to complete to preserve system *						integrity.  The intention is to allow system-level libraries *						to disable hardware components to conserve power while the system *						is asleep. * *  PARAMETERS:	refNum		-- Sample library reference number * *  CALLED BY:		System * *  RETURNS:		0						-- no error * *  CREATED:	5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/Err NSBTreoLibSleep(UInt16 refNum){	return( 0 );}/************************************************************ * *  FUNCTION: SampleLibWake * *  DESCRIPTION:	Handles system wake notification * *						***IMPORTANT*** *						This notification function is called from a system interrupt. *						It is only allowed to use system services which are interrupt- *						safe.  Presently, this is limited to EvtEnqueueKey, SysDisableInts, *						SysRestoreStatus.  Because it is called from an interrupt, *						it must *not* take a long time to complete to preserve system *						integrity.  The intention is to allow system-level libraries *						to enable hardware components which were disabled when the system *						went to sleep. * *  PARAMETERS:	refNum		-- Sample library reference number * *  CALLED BY:	System * *  RETURNS:	0						-- no error * *  CREATED:	5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/Err NSBTreoLibWake(UInt16 refNum){	return( 0 );}Err MainNumber(UInt16 refNum, char *ret){	Err err = errNone;	PhnAddressHandle address;	PhnAddressList list;	WITHGLOBALS	if (PhnLibModulePowered(gP -> phoneLibRefNum))	{		err = PhnLibGetOwnNumbers(gP -> phoneLibRefNum, &list);		if (!err)		{			UInt32 phnType;			HsAttrGet(hsAttrPhoneType, 0, &phnType);			if (phnType == hsAttrPhoneTypeCDMA)			{				err = PhnLibAPGetNth(gP -> phoneLibRefNum, list, 1, &address);				if (!err)				{						if (address)					{	// Get the number						CharPtr number;						number = PhnLibAPGetField(gP -> phoneLibRefNum, address, phnAddrFldPhone);						if (number)						{							StrCopy(ret, number);							MemPtrFree(number);						}						else						{							StrCopy(ret, "ERROR: Number not found");						}						MemHandleFree(address);					}					else					{						StrCopy(ret, "ERROR: Number not found");					}				}			}			else			{				err = PhnLibGetNth(gP -> phoneLibRefNum, list, 1, &address);				if (!err)				{						if (address)					{	// Get the voice phone number						CharPtr number;						number = PhnLibGetField(gP -> phoneLibRefNum, address, phnAddrFldPhone);						if (number)						{							StrCopy(ret, number);							MemPtrFree(number);						}						else						{							StrCopy(ret, "ERROR: Number not found");						}						MemHandleFree(address);					}					else					{						StrCopy(ret, "ERROR: Number not found");					}				}			}			MemHandleFree(list);			}	}	else	{		StrCopy(ret, "ERROR: Phone not on");	}	ENDWITHGLOBALS	return errNone;}Err PhoneOn(UInt16 refNum, long *ret){	WITHGLOBALS	*ret = PhnLibModulePowered(gP -> phoneLibRefNum) ? -1 : 0;	ENDWITHGLOBALS	return errNone;}Err PhoneTurnOn(UInt16 refNum){	HsTurnRadioOn();	return errNone;}Err TCPIPDropConnection(UInt16 refNum){	HsNetworkDropConnection();	return errNone;}Err Vibrate(UInt16 refNum, long *count){	UInt16 vibrate = kIndicatorAlertAlert;	HsIndicatorState((UInt16) *count, kIndicatorTypeVibrator, &vibrate);	return errNone;}Err Blink(UInt16 refNum, long *count){	UInt16 blink = kIndicatorAlertAlert;	HsIndicatorState((UInt16) *count, kIndicatorTypeLed, &blink);	return errNone;}Err Roaming(UInt16 refNum, long *ret){	Err err;	PhnRoamStatus roamStatus;	WITHGLOBALS	err = PhnLibRoaming(gP -> phoneLibRefNum, &roamStatus);	if (errNone == err)	{		if (PhnRoamStatusOff == roamStatus)		{			*ret = 0;		}		else		{			*ret = -1;		}	}	else	{		*ret = 0;	}	ENDWITHGLOBALS	return errNone;}Err Software(UInt16 refNum, char *ret){	Err err;	err = HsGetVersionString(hsVerStrComplete, ret, NULL);	if (err != errNone) *ret = '\0';	return errNone;}Err Hardware(UInt16 refNum, char *ret){	Err err;	err = HsGetVersionString(hsVerStrHardware, ret, NULL);	if (err != errNone) *ret = '\0';	return errNone;}Err ProductName(UInt16 refNum, char *ret){	Err err;	err = HsGetVersionString(hsVerStrProductName, ret, NULL);	if (err != errNone) *ret = '\0';	return errNone;}Err SerialNumber(UInt16 refNum, char *ret){	Err err;	err = HsGetVersionString(hsVerStrSerialNo, ret, NULL);	if (err != errNone) *ret = '\0';	return errNone;}Err CarrierID(UInt16 refNum, char *ret){	Err err;	err = HsGetVersionString(hsVerStrCarrierID, ret, NULL);	if (err != errNone) *ret = '\0';	return errNone;}Err ProductRevision(UInt16 refNum, char *ret){	Err err;	err = HsGetVersionString(hsVerStrCarrierID, ret, NULL);	if (err != errNone) *ret = '\0';	return errNone;}Err ROM(UInt16 refNum, char *ret){	Err err;	err = HsGetVersionString(hsVerStrROMBuild, ret, NULL);	if (err != errNone) *ret = '\0';	return errNone;}Err Firmware(UInt16 refNum, char *ret){	Err err;	err = HsGetVersionString(hsVerStrFirmwareVer, ret, NULL);	if (err != errNone) *ret = '\0';	return errNone;}Err NetworkAvailable(UInt16 refNum, long *ret){	WITHGLOBALS		if (PhnLibModulePowered(gP -> phoneLibRefNum))	{		*ret = PhnLibNetworkAvailable(gP -> phoneLibRefNum) ? -1 : 0;	}	else	{		*ret = 0;	}	ENDWITHGLOBALS	return errNone;}Err SignalQuality(UInt16 refNum, long *ret){	Err err;	UInt16 quality;		WITHGLOBALS	err = PhnLibSignalQuality (gP -> phoneLibRefNum, &quality);	if (!err)	{		*ret = quality;	}	ENDWITHGLOBALS	return err;}Err PhoneType(UInt16 refNum, char *ret){	UInt32 phnType = hsAttrPhoneTypeGSM; 	HsAttrGet(hsAttrPhoneType, 0, &phnType);	if (phnType == hsAttrPhoneTypeGSM)	{		StrCopy(ret, "GSM");	}	else	{		StrCopy(ret, "CDMA");	}		return errNone;}  Err PhoneReady(UInt16 refNum, long *ret){		WITHGLOBALS	// Make sure that the phone is powered...	if (PhnLibModulePowered(gP -> phoneLibRefNum))	{		UInt32 phnType = 0;		HsAttrGet(hsAttrPhoneType, 0, &phnType);				//Check if radio has initiliazed the SIM on GSM phone		if (PhnLibGetSIMStatus(gP -> phoneLibRefNum) != simReady &&			phnType == hsAttrPhoneTypeGSM)		{			*ret = 0;		}		else		{			if (PhnLibRegistered(gP -> phoneLibRefNum))				*ret = -1;			else				*ret = 0;		}	}	else	{		*ret = 0;	}	ENDWITHGLOBALS		return errNone;}Err BookCount(UInt16 refNum, long *ret){	Err err = errNone;		WITHGLOBALS	UInt32 phnType;	HsAttrGet(hsAttrPhoneType, 0, &phnType);	if (phnType == hsAttrPhoneTypeCDMA)	{		err = errNone;		*ret = 0;	}	else	{		if (NULL == gP -> list)		{			PhnPhoneBookInfoType info;			err = PhnLibGetPhoneBook(gP -> phoneLibRefNum, &(gP -> list), &info);		}		if (errNone == err)		{			UInt16 count;			err = PhnLibCount(gP -> phoneLibRefNum, gP -> list, &count);			if (errNone == err)			{				*ret = count;			}			else			{				*ret = 0;			}		}		else		{			*ret = 0;		}	}	ENDWITHGLOBALS		return errNone;}Err BookFirstName(UInt16 refNum, long idx, char *ret){	Err err = errNone;	PhnAddressHandle address;	Int16 which = idx;		WITHGLOBALS	if (NULL == gP -> list)	{		PhnPhoneBookInfoType info;		err = PhnLibGetPhoneBook(gP -> phoneLibRefNum, &(gP -> list), &info);	}	if (errNone == err)	{		UInt16 count;		err = PhnLibCount(gP -> phoneLibRefNum, gP -> list, &count);		if (errNone == err && which >= 0 && which < count)		{			UInt32 phnType;			HsAttrGet(hsAttrPhoneType, 0, &phnType);			if (phnType == hsAttrPhoneTypeCDMA)			{				err = PhnLibAPGetNth(gP -> phoneLibRefNum, gP -> list, which, &address);				if (!err)				{						if (address)					{	// Get the number						CharPtr number;						number = PhnLibAPGetField(gP -> phoneLibRefNum, address, phnAddrFldFirstName);						if (number)						{							StrCopy(ret, number);							MemPtrFree(number);						}						else						{							StrCopy(ret, "ERROR: Name not found");						}						MemHandleFree(address);					}					else					{						StrCopy(ret, "ERROR: Name not found");					}				}			}			else			{				err = PhnLibGetNth(gP -> phoneLibRefNum, gP -> list, which, &address);				if (!err)				{						if (address)					{	// Get the voice phone number						CharPtr number;						number = PhnLibGetField(gP -> phoneLibRefNum, address, phnAddrFldFirstName);						if (number)						{							StrCopy(ret, number);							MemPtrFree(number);						}						else						{							StrCopy(ret, "ERROR: Name not found");						}						MemHandleFree(address);					}					else					{						StrCopy(ret, "ERROR: Name not found");					}				}			}				}		else		{			*ret = 0;		}	}	else	{		*ret = 0;	}	ENDWITHGLOBALS		return errNone;}Err BookLastName(UInt16 refNum, long idx, char *ret){	Err err = errNone;	PhnAddressHandle address;	Int16 which = idx;		WITHGLOBALS	if (NULL == gP -> list)	{		PhnPhoneBookInfoType info;		err = PhnLibGetPhoneBook(gP -> phoneLibRefNum, &(gP -> list), &info);	}	if (errNone == err)	{		UInt16 count;		err = PhnLibCount(gP -> phoneLibRefNum, gP -> list, &count);		if (errNone == err && which >= 0 && which < count)		{			UInt32 phnType;			HsAttrGet(hsAttrPhoneType, 0, &phnType);			if (phnType == hsAttrPhoneTypeCDMA)			{				err = PhnLibAPGetNth(gP -> phoneLibRefNum, gP -> list, which, &address);				if (!err)				{						if (address)					{	// Get the number						CharPtr number;						number = PhnLibAPGetField(gP -> phoneLibRefNum, address, phnAddrFldLastName);						if (number)						{							StrCopy(ret, number);							MemPtrFree(number);						}						else						{							StrCopy(ret, "ERROR: Name not found");						}						MemHandleFree(address);					}					else					{						StrCopy(ret, "ERROR: Name not found");					}				}			}			else			{				err = PhnLibGetNth(gP -> phoneLibRefNum, gP -> list, which, &address);				if (!err)				{						if (address)					{	// Get the voice phone number						CharPtr number;						number = PhnLibGetField(gP -> phoneLibRefNum, address, phnAddrFldLastName);						if (number)						{							StrCopy(ret, number);							MemPtrFree(number);						}						else						{							StrCopy(ret, "ERROR: Name not found");						}						MemHandleFree(address);					}					else					{						StrCopy(ret, "ERROR: Name not found");					}				}			}				}		else		{			*ret = 0;		}	}	else	{		*ret = 0;	}	ENDWITHGLOBALS		return errNone;}Err BookPhoneNumber(UInt16 refNum, long idx, char *ret){	Err err = errNone;	PhnAddressHandle address;	Int16 which = idx;		WITHGLOBALS	if (NULL == gP -> list)	{		PhnPhoneBookInfoType info;		err = PhnLibGetPhoneBook(gP -> phoneLibRefNum, &(gP -> list), &info);	}	if (errNone == err)	{		UInt16 count;		err = PhnLibCount(gP -> phoneLibRefNum, gP -> list, &count);		if (errNone == err && which >= 0 && which < count)		{			UInt32 phnType;			HsAttrGet(hsAttrPhoneType, 0, &phnType);			if (phnType == hsAttrPhoneTypeCDMA)			{				err = PhnLibAPGetNth(gP -> phoneLibRefNum, gP -> list, which, &address);				if (!err)				{						if (address)					{	// Get the number						CharPtr number;						number = PhnLibAPGetField(gP -> phoneLibRefNum, address, phnAddrFldPhone);						if (number)						{							StrCopy(ret, number);							MemPtrFree(number);						}						else						{							StrCopy(ret, "ERROR: Number not found");						}						MemHandleFree(address);					}					else					{						StrCopy(ret, "ERROR: Number not found");					}				}			}			else			{				err = PhnLibGetNth(gP -> phoneLibRefNum, gP -> list, which, &address);				if (!err)				{						if (address)					{	// Get the voice phone number						CharPtr number;						number = PhnLibGetField(gP -> phoneLibRefNum, address, phnAddrFldPhone);						if (number)						{							StrCopy(ret, number);							MemPtrFree(number);						}						else						{							StrCopy(ret, "ERROR: Number not found");						}						MemHandleFree(address);					}					else					{						StrCopy(ret, "ERROR: Number not found");					}				}			}				}		else		{			*ret = 0;		}	}	else	{		*ret = 0;	}	ENDWITHGLOBALS		return errNone;}Err BookReload(UInt16 refNum){	WITHGLOBALS	if (NULL != gP -> list)	{		MemHandleFree(gP -> list);		gP -> list = NULL;	}	ENDWITHGLOBALS	return errNone;}Err Provider(UInt16 refNum, char *ret){	Err err = errNone;	PhnOperatorID ID;	char *str;	GSMRegistrationMode mode;		WITHGLOBALS	err = PhnLibCurrentProvider(gP -> phoneLibRefNum, &str);	if (errNone == err)	{		if (*str)		{			StrCopy(ret, str);		}		else		{			err = PhnLibCurrentOperator(gP -> phoneLibRefNum, &ID, &str, &mode);			if (errNone == err)			{				StrCopy(ret, str);			}			else			{				StrCopy(ret, "ERROR: No current provider");			}		}	}	else	{		err = PhnLibCurrentOperator(gP -> phoneLibRefNum, &ID, &str, &mode);		if (errNone == err)		{			StrCopy(ret, str);		}		else		{			StrCopy(ret, "ERROR: No current provider");		}	}	ENDWITHGLOBALS			return errNone;}Err OperatorCurName(UInt16 refNum, char *ret){	Err err;	PhnOperatorID ID;	char *str;	GSMRegistrationMode mode;		WITHGLOBALS	err = PhnLibCurrentOperator(gP -> phoneLibRefNum, &ID, &str, &mode);	if (errNone == err)	{		StrCopy(ret, str);	}	else	{		StrCopy(ret, "ERROR: No current operator");	}	ENDWITHGLOBALS	return errNone;}Err OperatorCurID(UInt16 refNum, char *ret){	Err err;	Int16 size = 299;		WITHGLOBALS	err = PhnLibCurrentOperatorID (gP -> phoneLibRefNum, ret,		&size);	if (errNone != err)	{		StrCopy(ret, "ERROR: No current operator");	}	ENDWITHGLOBALS		return errNone;}Err OperatorCount(UInt16 refNum, long *ret){	Err err;	PhnOperatorListPtr list;		WITHGLOBALS	err = PhnLibGetOperatorList(gP -> phoneLibRefNum, &list);	if (errNone == err)	{		*ret = list -> count;	}	else	{		*ret = 0;	}	ENDWITHGLOBALS		return errNone;}Err OperatorName(UInt16 refNum, long idx, char *ret){	Err err;	PhnOperatorListPtr list;	Int16 which = idx;		WITHGLOBALS	err = PhnLibGetOperatorList(gP -> phoneLibRefNum, &list);	if (errNone == err)	{		which = which - 1;		if (which >= 0 && which < list -> count)		{			if (list -> opData[which].longname[0])			{				StrCopy(ret, list -> opData[which].longname);			}			else			{				StrCopy(ret, list -> opData[which].shortname);			}		}		else		{			*ret = '\0';		}	}	else	{		*ret = 0;	}	ENDWITHGLOBALS		return errNone;} Err Operator(UInt16 refNum, long idx, long type){	Err err;	PhnOperatorListPtr list;	Int16 which = idx;		WITHGLOBALS	err = PhnLibGetOperatorList(gP -> phoneLibRefNum, &list);	if (errNone == err)	{		which = which - 1;		if (which >= 0 && which < list -> count)		{			err = PhnLibSetOperator(gP -> phoneLibRefNum,				&(list -> opData[which]), type);		}	}	ENDWITHGLOBALS		return err;}Err DialPhone(UInt16 refNum, char *number){	char buf[1];	buf[0] = '\0';	HsOpenDialNumberDialog(number, buf, true);	return errNone;}Err SendEMail(UInt16 refNum, char *addr, char *cc, char *subj, char *msg){	HsCreateNewEmail(addr, cc, subj, msg);	return errNone;}Err SendSMSMessage(UInt16 refNum, char *nbr, char *name, char *msg){	HsCreateNewMessage(nbr, name, msg);	return errNone;}Err Browse(UInt16 refNum, char *URL){	HsBrowseUrl(URL);	return errNone;}Err CallWaitingSet(UInt16 refNum, long whether){	Err err;	WITHGLOBALS	err = PhnLibSetCallWaiting(gP -> phoneLibRefNum, whether ? true : false);	ENDWITHGLOBALS	return err;}Err CallWaiting(UInt16 refNum, long *ret){	Err err;	Boolean whether = false;	WITHGLOBALS	err = PhnLibGetCallWaiting(gP -> phoneLibRefNum,&whether);	*ret = whether ? -1 : 0;	ENDWITHGLOBALS	return errNone;}Err KeyboardLocked(UInt16 refNum, long *ret){	UInt32 value = 0;	Err err = HsAttrGet(hsAttrKeyboardLocked, 0, &value);	*ret = value ? -1 : 0;	return errNone;}Err KeyboardLock(UInt16 refNum, long inVal){	UInt32 value = inVal ? 1 : 0;	Err err = HsAttrSet(hsAttrKeyboardLocked, 0, &value);	return err;}/* HTTP code *//* callbacks */static Int32 PrvTCPOpen(Int32 in_domain, HS_HTTPLibOpaque in_aux){	NetSocketRef	sockRef;	Err 					error;	UInt16				 flag;	UInt16					sizeFlag = sizeof(flag);	Int16 				ret;	NetSocketLingerType lin;		WITHCRYPTOGLOBALS	sockRef = NetLibSocketOpen(gP -> appNetLibNum, netSocketAddrINET,netSocketTypeStream,netSocketProtoIPTCP, TCP_TIMEOUT, &error);	flag = 1;	/* set to non-blocking socket */	ret = NetLibSocketOptionSet(gP -> appNetLibNum, sockRef, netSocketOptLevelSocket,netSocketOptSockNonBlocking, &flag, sizeFlag, TCP_TIMEOUT, &error);	lin.onOff = true;	lin.time = 0;	/* set linger */	ret = NetLibSocketOptionSet(gP -> appNetLibNum, sockRef, netSocketOptLevelSocket,netSocketOptSockLinger, &lin, sizeof(lin),TCP_TIMEOUT, &error);	/* netSocketAddrRaw : netSocketAddrINET */	/* netSocketTypeDatagram : netSocketTypeRaw : netSocketTypeReliableMsg */	/* netSocketIPTCP : netSocketIPUDP : netSocketIPRAW */	if (error){		NetLibSocketClose(gP -> appNetLibNum, sockRef,20000/*timeout*/, &error);		sockRef = httpErrorGeneric;	}	ENDWITHCRYPTOGLOBALS		return sockRef;}static void PrvTCPClose(Int32 in_desc, HS_HTTPLibOpaque in_aux){	Int16  result;	Int32 timeout = TCP_TIMEOUT;	Err 	 error = 0;	if(in_desc == -1) return;	WITHCRYPTOGLOBALS	result = NetLibSocketClose(gP -> appNetLibNum, (NetSocketRef)in_desc,timeout, &error);	ENDWITHCRYPTOGLOBALS}static Int32 PrvTCPIsConnected(Int32 in_desc, HS_HTTPLibOpaque in_aux){	NetFDSetType	fds, wfds, dummy;	Err 					error;	long					timeout = TCP_TIMEOUT;	Int16 				ret;	UInt16					width;	width = in_desc + 1;	netFDZero(&fds);	netFDSet((NetSocketRef)in_desc, &fds);	netFDZero(&wfds);	netFDSet((NetSocketRef)in_desc, &wfds);	netFDZero(&dummy);	WITHCRYPTOGLOBALS	ret = NetLibSelect(gP -> appNetLibNum, width, &fds, &wfds, &dummy,timeout, &error);	ENDWITHCRYPTOGLOBALS	return ret;}static Int32 PrvTCPConnect(Int32 in_desc, HS_HTTPLibIPAddr *in_addr, Int32 in_port, HS_HTTPLibOpaque in_aux){	Err 								 error;	NetSocketAddrINType  sockAddr;	Int32 							timeout = TCP_TIMEOUT;	Int16 							 result;	Int16 							 addrlen = sizeof(sockAddr);	/* Address setup */	MemSet(&sockAddr, addrlen, 0);		sockAddr.family = netSocketAddrINET;	sockAddr.port = (UInt16)NetHToNS((UInt16)in_port);	{			Char*  src;			Int16 index = 0;			/* memcpy */			for (src = (Char*)in_addr->addr; index < 4; index++)				*((Char*)&sockAddr.addr + index) = *(src + index);	}	/*	sockAddr.addr = PALM_NetLibAddrAToIN((Char*)in_addr); */	/* connect */	WITHCRYPTOGLOBALS	result = NetLibSocketConnect(gP -> appNetLibNum, (Int16)in_desc,(NetSocketAddrType*)&sockAddr, addrlen,timeout, &error);	ENDWITHCRYPTOGLOBALS	if (result == -1) {		/* error */		switch (error) {		case netErrSocketAlreadyConnected:			result = httpErrorOK;		break;		case netErrSocketBusy:		case netErrWouldBlock:			result = httpErrorWouldBlock;		break;		default:			result = httpErrorGeneric;		break;		}	} else {		result = httpErrorOK;	}	return result;}static Int32 PrvTCPRead(Int32 in_desc, Char *out_buf, Int32 in_len, HS_HTTPLibOpaque in_aux){	Int16 	 result;	Int32 	 timeout = TCP_TIMEOUT;	UInt16		 flg = 0;	Err 		 error;	Int32 ret = 0x0000ffff;	if (in_len > READ_CHUNK) {		in_len = READ_CHUNK;	}	WITHCRYPTOGLOBALS	result = NetLibReceive(gP -> appNetLibNum, (NetSocketRef)in_desc,out_buf, (UInt16)in_len,flg, NULL, NULL, timeout, &error);	ENDWITHCRYPTOGLOBALS	if (result == -1){		switch (error) {		case netErrSocketBusy:		case netErrSocketNotConnected:		case netErrWouldBlock:			result = httpErrorWouldBlock;		break;		default:			result = httpErrorGeneric;		break;		}	} else {		ret &= result;		return ret;	}	return result;	}static Int32 PrvTCPWrite(Int32 in_desc, Char *in_buf, Int32 in_len, HS_HTTPLibOpaque in_aux){	Int16  result;	Int32  timeout = 5*SysTicksPerSecond();	UInt16	 flg = 0;	Err 	 error;	if (in_len > READ_CHUNK) {		in_len = READ_CHUNK;	}	WITHCRYPTOGLOBALS	result = NetLibSend(gP -> appNetLibNum, (NetSocketRef)in_desc, in_buf, (UInt16)in_len,0, 0, flg, timeout, &error);	ENDWITHCRYPTOGLOBALS	if (result == -1) {		switch (error) {		case netErrSocketBusy:		case netErrSocketNotConnected:		case netErrWouldBlock:			result = httpErrorWouldBlock;		break;		default:			result = httpErrorGeneric;		break;		}	} else {    	// DIKEO debug_text(in_buf, in_len);	}	return result;}static Int32 PrvTCPCanReadWrite(Int32 in_desc, Int32 in_rw, HS_HTTPLibOpaque in_aux){	NetFDSetType	fds, wfds, dummy;	Err 					error;	long					timeout = TCP_TIMEOUT;	Int16 				selected;	UInt16					width;	Int32 ret;	width = in_desc + 1;	netFDZero(&fds);	netFDSet((NetSocketRef)in_desc, &fds);	WITHCRYPTOGLOBALS	switch (in_rw) {	case httpStreamRead:		selected = NetLibSelect(gP -> appNetLibNum, width, &fds, NULL, &dummy,timeout, &error);			if (selected != 1){				ret = selected;			}else{				ret = httpStreamRead;			}	break;	case httpStreamWrite:		selected = NetLibSelect(gP -> appNetLibNum, width, NULL, &fds, &dummy,timeout, &error);		if (selected <=0){			ret = selected;		} else if (selected == 2){			ret = httpStreamReadWrite;		} else {			ret = httpStreamWrite;		}	break;	default:		netFDZero(&wfds);		netFDSet((NetSocketRef)in_desc, &wfds);		selected = NetLibSelect(gP -> appNetLibNum, width, &fds, &wfds, &dummy,timeout, &error);		if (selected <=0){			ret =  selected;		} else if (selected == 2){			ret = httpStreamReadWrite;		} else if (netFDIsSet((NetSocketRef)in_desc, &fds)){			ret = httpStreamRead;		}else{			ret = httpStreamWrite;		}	break;	}	ENDWITHCRYPTOGLOBALS	return ret;}static UInt16 get_instance(NSBTreoLibGlobalsPtr gP){	Err err;	UInt16 index,ifInstance;	UInt32 ifCreator;	UInt16 ret = 0xffff;	for(index = 0;1;index++){		err = NetLibIFGet(gP -> appNetLibNum, index, &ifCreator, &ifInstance);		if(err) break;		if(ifCreator == netIFCreatorPPP){			ret = ifInstance;			break;		}	}	return ret;}static Err ifup(NSBTreoLibGlobalsPtr gP){	UInt16 ifInstance;	Err err = -1;	UInt16 ifErrs;	Err retVal = -1;		if(gP -> isNetLibOpen == false){   		err = NetLibOpen(gP -> appNetLibNum, &ifErrs);        if (err || ifErrs) {            NetLibClose(gP -> appNetLibNum, true);           	err = -1;           	goto retErr;        }    	gP -> isNetLibOpen = true;	}	ifInstance = get_instance(gP);	if(ifInstance != 0xffff){		err = NetLibIFUp(gP -> appNetLibNum, netIFCreatorPPP,ifInstance);		if (!err) gP -> isNetLibUp = true;		}retErr:;	return err;}static Err ifdown(NSBTreoLibGlobalsPtr gP){	Err err = 0;	UInt16 ifInstance;		ifInstance = get_instance(gP);	if(ifInstance != 0xffff){		if (gP -> isNetLibUp) {			gP -> isNetLibUp = false;			//			err = NetLibClose(gP -> appNetLibNum, true);			err = NetLibIFDown(gP -> appNetLibNum, netIFCreatorPPP, ifInstance,-1);		}		}	else	{		err = -1;	}	return err;}static ErrPrvPeerInitialize(void){	Err err = -1;		WITHCRYPTOGLOBALS	gP -> isNetLibOpen = false;	err = SysLibFind("Net.lib", &(gP -> appNetLibNum));		if (gP -> appNetLibNum){		err = ifup(gP);	}else{		err = -1;	}	if(!err){		gP -> PPPConnectF = true;	}	else	{		gP -> PPPConnectF = false;	}	ENDWITHCRYPTOGLOBALS	return err;}static Err PrvPeerFinalize(NSBTreoLibGlobalsPtr gP){	Err err = 0;	if (gP -> appNetLibNum){		err = ifdown(gP);	}	gP -> PPPConnectF = false;	return err;}static Err GlueHTTPOpen(UInt32 stack1, UInt32 stack2, UInt16 refNum){    Err err = errNone;    WITHGLOBALS    /* load the library */	if( gP -> HTTPRefNum == sysInvalidRefNum ) {		err = SysLibFind(HS_HTTPLibName, &(gP -> HTTPRefNum));	    if (err) {	        err = SysLibLoad(HS_HTTPLibDBType, HS_HTTPLibID, &(gP -> HTTPRefNum));		}	}	gP -> fHTTPStream = NULL;	ENDWITHGLOBALS	if (errNone != err)	{		return err;	}		WITHGLOBALS	err = HS_HTTPLibOpen(gP -> HTTPRefNum);	if (err)	{			}	// DIKEO check error	/* gPeer */	gP -> HTTPPeer = (HS_HTTPLibPeer *)MemPtrNew(sizeof(HS_HTTPLibPeer));		MemSet(gP -> HTTPPeer, 0, sizeof(HS_HTTPLibPeer));	gP -> HTTPPeer -> HS_HTTPLibPeerTCPOpen = &PrvTCPOpen;	gP -> HTTPPeer -> HS_HTTPLibPeerTCPClose = &PrvTCPClose;	gP -> HTTPPeer -> HS_HTTPLibPeerTCPIsConnected = &PrvTCPIsConnected;	gP -> HTTPPeer -> HS_HTTPLibPeerTCPConnect = &PrvTCPConnect;	gP -> HTTPPeer -> HS_HTTPLibPeerTCPRead = &PrvTCPRead;	gP -> HTTPPeer -> HS_HTTPLibPeerTCPWrite = &PrvTCPWrite;	gP -> HTTPPeer -> HS_HTTPLibPeerTCPCanReadWrite = &PrvTCPCanReadWrite;	gP -> appInfo = (HS_HTTPLibAppInfo *)MemPtrNew(sizeof(HS_HTTPLibAppInfo));	MemSet(gP -> appInfo, 0, sizeof(HS_HTTPLibAppInfo));	//gP -> appInfo -> appCreator = 'NSBt';	//gP -> appInfo -> cookieDBName = MemPtrNew(16);	//StrCopy(gP -> appInfo -> cookieDBName, "Web Cookies");	//gP -> appInfo -> cookieDBCreator = 'BLZ4';	//gP -> appInfo -> cookieDBType = 'cuki';	//gP -> appInfo -> cookieDBVersion = 1;	//gP -> appInfo -> certDBName = MemPtrNew(16);	//StrCopy(gP -> appInfo -> certDBName, "NSBTreoCert");	//gP -> appInfo -> certDBType = 'cert';	//gP -> appInfo -> certDBVersion = 1;	gP -> appInfo -> maxSockets = 3;	gP -> appInfo -> isForeground = true;	gP -> appInfo -> cookieMaxJarSize = (UInt16)300 * (UInt16)1024;	gP -> appInfo -> cookieDBName = NULL;	gP -> netLibInfo = (HS_HTTPLibNetLibInfo *)MemPtrNew(sizeof(HS_HTTPLibNetLibInfo));	MemSet(gP -> netLibInfo, 0, sizeof(HS_HTTPLibNetLibInfo));	err = PrvPeerInitialize();	if (err)	{		// DIKEO return error	}	SysTaskDelay(SysTicksPerSecond());	gP -> libHandle = HS_HTTPLibInitialize(gP -> HTTPRefNum, gP -> appInfo, gP -> netLibInfo, gP -> HTTPPeer);	if (!gP -> libHandle)	{		// DIKEO return error	}		/* set callbacks */	//HS_HTTPLibSetSSLServerCertConfirmProc(gP -> HTTPRefNum, gLibHandle, &test_confirm_cb, (HS_HTTPLibOpaque)gLibHandle);	//HS_HTTPLibSetTunnelingCallback(gP -> HTTPRefNum, gLibHandle, &PrvTunnelingCallback, NULL);		/* set timeout time */	HS_HTTPLibSetConnectTimeOut(gP -> HTTPRefNum, gP -> libHandle, -1);	HS_HTTPLibSetReqTimeOut(gP -> HTTPRefNum, gP -> libHandle, -1);	HS_HTTPLibSetRspTimeOut(gP -> HTTPRefNum, gP -> libHandle, 10 * 1000);		/* set proxy info */	//HS_HTTPLibSetProxy(gP -> HTTPRefNum, gLibHandle, ProxyHost, StrLen(ProxyHost), ProxyPort, ProxyPort, NoProxyHost, 0);	//HS_HTTPLibSetUseProxy(gP -> HTTPRefNum, gLibHandle, true);	ENDWITHGLOBALSdone:		return err;}Err HTTPOpen(UInt16 refNum, long *ret){	Err err = GlueHTTPOpen(STACK1, STACK2, refNum);	*ret = err ? 0 : -1;	return errNone;}static Err GlueHTTPClose(UInt32 stack1, UInt32 stack2, UInt16 refNum){	Err err;	UInt16 count;		WITHGLOBALS	if (gP -> fHTTPStream)	{			HS_HTTPLibStreamClose(gP -> HTTPRefNum, gP->fHTTPStream );	/* Close HTTP */			HS_HTTPLibStreamDelete(gP -> HTTPRefNum, gP->fHTTPStream );			gP->fHTTPStream = NULL;	}	HS_HTTPLibFinalize(gP -> HTTPRefNum, gP -> libHandle);	PrvPeerFinalize(gP);	gP -> libHandle = NULL;		err = HS_HTTPLibClose(gP -> HTTPRefNum, &count);	gP -> isNetLibOpen = false;	gP -> isNetLibUp = false;		/* unload the library */	if( gP -> HTTPRefNum != sysInvalidRefNum ){		SysLibRemove(gP -> HTTPRefNum);		gP -> HTTPRefNum = sysInvalidRefNum;	}	//MemPtrFree(gP -> appInfo -> cookieDBName);	//MemPtrFree(gP -> appInfo -> certDBName);	MemPtrFree(gP -> appInfo);	MemPtrFree(gP -> netLibInfo);	MemPtrFree(gP -> HTTPPeer);	gP -> appInfo = NULL;	gP -> netLibInfo = NULL;	gP -> HTTPPeer = NULL;	ENDWITHGLOBALS	return err;}Err HTTPClose(UInt16 refNum){	return GlueHTTPClose(STACK1, STACK2, refNum);}static Err GlueHTTPSendRequest(UInt32 stack1, UInt32 stack2, UInt16 refNum, char *url, long timeInMs){	Err err = errNone;	Int32 result;	Int32 k;	UInt32 ticks;	UInt32 delta;		WITHGLOBALS	gP -> requestPending = true;	gP -> fHTTPStream = HS_HTTPLibStreamNew(gP -> HTTPRefNum, gP -> libHandle);	if(!gP -> fHTTPStream)	{		err = -1;	}	else	{			result = HS_HTTPLibStreamCreateRequest(gP -> HTTPRefNum,  gP -> fHTTPStream, httpMethodGET, 				url, StrLen(url), "", 0, "", 0, 				httpVersion_1_1, false, false, httpSSLFlagConnV2V3TLS);		HS_HTTPLibStreamAddHeader(gP -> HTTPRefNum, gP -> fHTTPStream, httpHeaderIDAcceptEncoding, "*/*", 3);			ticks = TimGetTicks();		k = 0;		while (delta = TimGetTicks() - ticks,			   delta = (delta << 3) + (delta << 2),			   delta < timeInMs)		{			++k;			result = HS_HTTPLibStreamSendRequest(gP -> HTTPRefNum, gP -> fHTTPStream, NULL);			if(result == httpErrorOK)			{				err = errNone;				break;			}else if(result == httpErrorWouldBlock){			}			else			{				err = httpErrorWouldBlock;				break;			}			SysTaskDelay(DORMANCY);			if (err)			{				HS_HTTPLibStreamClose(gP -> HTTPRefNum, gP->fHTTPStream );	/* Close HTTP */				HS_HTTPLibStreamDelete(gP -> HTTPRefNum, gP->fHTTPStream );				gP->fHTTPStream = NULL;			}		}	}	ENDWITHGLOBALS		return err;}static Err GlueHTTPEnd(UInt32 stack1, UInt32 stack2, UInt16 refNum){	WITHGLOBALS	if (gP -> fHTTPStream)	{		HS_HTTPLibStreamClose(gP -> HTTPRefNum, gP->fHTTPStream);	/* Close HTTP */		HS_HTTPLibStreamDelete(gP -> HTTPRefNum, gP->fHTTPStream);		gP->fHTTPStream = NULL;	}	ENDWITHGLOBALS	return errNone;}Err HTTPEnd(UInt16 refNum){	GlueHTTPEnd(STACK1, STACK2, refNum);	return errNone;}Err HTTPSendRequest(UInt16 refNum, char *url, long timeInMs, long *ret){	Err err = GlueHTTPSendRequest(STACK1, STACK2, refNum, url, timeInMs);	*ret = err ? 0 : -1;	return errNone;}static Err GlueHTTPSendPostRequest(UInt32 stack1, UInt32 stack2, UInt16 refNum, char *url, char *postData, long timeInMs){	Err err = errNone;	Int32 result;	Int32 k;	UInt32 ticks;	UInt32 delta;		WITHGLOBALS	gP -> requestPending = true;	gP -> fHTTPStream = HS_HTTPLibStreamNew(gP -> HTTPRefNum, gP -> libHandle);	if(!gP -> fHTTPStream)	{		err = -1;	}	else	{			result = HS_HTTPLibStreamCreateRequest(gP -> HTTPRefNum,  gP -> fHTTPStream, httpMethodPOST, 				url, StrLen(url), "", 0, "", 0, 				httpVersion_1_1, false, false, httpSSLFlagConnV2V3TLS);		HS_HTTPLibStreamSetPostData(gP -> HTTPRefNum, gP -> fHTTPStream, httpPostURLENCODED, postData, StrLen(postData));		//HS_HTTPLibStreamAddHeader(gP -> HTTPRefNum, gP -> fHTTPStream, httpHeaderIDAcceptEncoding, "*/*", 3);			ticks = TimGetTicks();		k = 0;		while (delta = TimGetTicks() - ticks,			   delta = (delta << 3) + (delta << 2),			   delta < timeInMs)		{			++k;			result = HS_HTTPLibStreamSendRequest(gP -> HTTPRefNum, gP -> fHTTPStream, NULL);			if(result == httpErrorOK)			{				err = errNone;				break;			}else if(result == httpErrorWouldBlock){			}			else			{				err = httpErrorWouldBlock;				break;			}			SysTaskDelay(DORMANCY);		}				if (err)		{			HS_HTTPLibStreamClose(gP -> HTTPRefNum, gP->fHTTPStream );	/* Close HTTP */			HS_HTTPLibStreamDelete(gP -> HTTPRefNum, gP->fHTTPStream );			gP->fHTTPStream = NULL;		}	}	ENDWITHGLOBALS		return err;}Err HTTPSendPostRequest(UInt16 refNum, char *url, char *postData, long timeInMs, long *ret){	Err err = GlueHTTPSendRequest(STACK1, STACK2, refNum, url, timeInMs);	*ret = err ? 0 : -1;	return errNone;}static Err GlueHTTPGetHeader(UInt32 stack1, UInt32 stack2, UInt16 refNum, Int32 *lenIn, HS_HTTPLibVHandle *handle, UInt32 timeInMs){	Int32 result;	Int32 len=0;	Err err = -1;	HS_HTTPLibVHandle hdrH = NULL;	UInt32 contentLength;		Int32 k;	UInt32 ticks;	UInt32 delta;		k = 0;	*lenIn = 0;	WITHGLOBALS	ticks = TimGetTicks();	while (delta = TimGetTicks() - ticks,		   delta = (delta << 3) + (delta << 2),		   delta < timeInMs)	{		result = HS_HTTPLibStreamReceiveResponse(gP -> HTTPRefNum, gP -> fHTTPStream, NULL, 0, &len, NULL);		hdrH = HS_HTTPLibStreamGetResponseHeader(gP -> HTTPRefNum, gP -> fHTTPStream);		switch(result){		case httpErrorOK:		case httpErrorWouldBlock:			if(HS_HTTPLibStreamIsHeaderReceived(gP -> HTTPRefNum, gP -> fHTTPStream)){				contentLength = HS_HTTPLibStreamGetContentLength(gP -> HTTPRefNum, gP -> fHTTPStream);				*handle = hdrH;				*lenIn = HS_HTTPLibStreamGetResponseHeaderLength(gP -> HTTPRefNum, gP -> fHTTPStream);				err = errNone;				goto exit;			}			else			{				Int32	hLen;				hLen = HS_HTTPLibStreamGetResponseHeaderLength(gP -> HTTPRefNum, gP -> fHTTPStream);			}		break;		default:			break;		break;		}		SysTaskDelay(DORMANCY);	}exit:;	ENDWITHGLOBALS	return errNone;}Err HTTPGetHeader(UInt16 refNum, long timeInMs, char *ret){	HS_HTTPLibVHandle hdrH = NULL;	Int32 lenIn;	Err err = errNone;	WITHGLOBALS	err = GlueHTTPGetHeader(STACK1, STACK2, refNum, &lenIn, &hdrH, timeInMs);	if (errNone == err)	{		if (hdrH)		{			Char *p;			MemPtr *d;			MemHandle h = MemPtrRecoverHandle(((char *)ret) - sizeof(MemHandle));						MemHandleUnlock(h);			MemHandleResize(h, lenIn + 1 + sizeof(MemPtr));			d = ((MemPtr *)MemHandleLock(h));			*d = d + 1;						p = (Char *)HS_HTTPLibVHandle_Lock(gP -> HTTPRefNum, hdrH);			MemMove(d + 1, p, lenIn);			((char *)(d + 1))[lenIn] = '\0';			HS_HTTPLibVHandle_Unlock(gP -> HTTPRefNum, hdrH);		}		else		{			StrCopy(ret, "");		}	}	else	{		StrCopy(ret, "");	}	ENDWITHGLOBALS	return errNone;}static Err GlueHTTPRead(UInt32 stack1, UInt32 stack2, UInt16 refNum, long size, Int32 *lenIn, char *ret, UInt32 timeInMs){	Int32 len=0;	Err err = -1;	HS_HTTPLibVHandle hdrH = NULL;	UInt32 remainingLength = size;	UInt32 offset = 0;		Int32 k;	UInt32 ticks;	UInt32 delta;		k = 0;	*lenIn = 0;	WITHGLOBALS	if (gP -> requestPending)	{		ticks = TimGetTicks();		while (delta = TimGetTicks() - ticks,			   delta = (delta << 3) + (delta << 2),			   delta < timeInMs)		{			err = HS_HTTPLibStreamReceiveResponse(gP -> HTTPRefNum, gP -> fHTTPStream, 							ret + offset, size - offset, &len, NULL);														switch(err){			case httpErrorOK:			case httpErrorWouldBlock:			case httpErrorIOSleep:				if(len > 0){					offset += len;				}								if (offset >= size || httpErrorOK == err)				{					/* Return with this done */					*lenIn = offset;					if (httpErrorOK == err)					{						gP -> requestPending = false;					}					goto exit;				}						break;			default:				break;			break;			}			SysTaskDelay(DORMANCY);		}	}	else	{		*ret = '\0';		err = httpErrorOK;	}exit:;	ENDWITHGLOBALS	return err;}Err HTTPRead(UInt16 refNum, long size, long timeInMs, char *ret){	Int32 lenIn = 0;	Err err = errNone;	MemPtr *d;	MemHandle h;	long locSize;		locSize = size + 1;	if (locSize < 300) locSize = 300;	h = MemPtrRecoverHandle(((char *)ret) - sizeof(MemHandle));		MemHandleUnlock(h);	MemHandleResize(h, locSize + sizeof(MemPtr));	d = ((MemPtr *)MemHandleLock(h));	*d = d + 1;	WITHGLOBALS	err = GlueHTTPRead(STACK1, STACK2, refNum, size, &lenIn, ret, timeInMs);	if (errNone == err ||		httpErrorOK == err ||		httpErrorWouldBlock == err ||		httpErrorIOSleep == err)	{		ret[lenIn] = '\0';	}	else	{		StrCopy(ret, "ERROR: Read error");	}	ENDWITHGLOBALS	return errNone;}/************************************************************ * *  FUNCTION: PrvMakeGlobals * *  DESCRIPTION:	Create our library globals. * *  PARAMETERS:	refNum		-- Sample library reference number * *  CALLED BY:		internal * *  RETURNS:		pointer to our *locked* library globals; NULL if our globals *						could not be created. * *  CREATED: 5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static NSBTreoLibGlobalsPtr PrvMakeGlobals(UInt16 refNum){	NSBTreoLibGlobalsPtr	gP = NULL;							// our globals pointer	MemHandle				gH;									// our globals handle	SysLibTblEntryPtr		libEntryP;							// pointer to our library table entry	// Get library globals	libEntryP = SysLibTblEntry(refNum);						// get our system library table entry	ErrFatalDisplayIf(libEntryP == NULL, "invalid Sample lib refNum");		// Error check to make sure the globals don't already exist	ErrFatalDisplayIf(libEntryP->globalsP, "Sample lib globals already exist");			// Allocate and initialize our library globals.	gH = MemHandleNew(sizeof(NSBTreoLibGlobalsType));	if ( !gH )		return( NULL );											// memory allocation error		// Save the handle of our library globals in the system library table entry so we	// can later retrieve it using SysLibTblEntry().	libEntryP->globalsP = (void*)gH;	// Lock our globals	gP = PrvLockGlobals(refNum);				// this should not fail	ErrFatalDisplayIf(gP == NULL, "Failed to lock Sample lib globals");				// Set the owner of our globals memory chunk to "system" (zero), so it won't get	// freed automatically by Memory Manager when the first application to call	// SampleLibOpen exits.  This is important if the library is going to stay open	// between apps.	MemPtrSetOwner(gP, 0);		// Initialize our library globals	MemSet(gP, sizeof(NSBTreoLibGlobalsType), 0);	gP->thisLibRefNum = refNum;		// for convenience and debugging (althouth not used in this sample library)	gP->openCount = 0;					// initial open count		return( gP );							// return a pointer to our *locked* globals}/************************************************************ * *  FUNCTION: PrvFreeGlobals * *  DESCRIPTION:	Free our library globals. * *  PARAMETERS:	refNum		-- Sample library reference number * *  CALLED BY:		internal * *  RETURNS:		nothing * *  CREATED: 5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static void PrvFreeGlobals(UInt16 refNum){	MemHandle					gH;									// our globals handle	SysLibTblEntryPtr		libEntryP;							// pointer to our library table entry	// Get our library globals handle	libEntryP = SysLibTblEntry(refNum);						// get our system library table entry	ErrFatalDisplayIf(libEntryP == NULL, "invalid Sample lib refNum");		gH = (MemHandle)(libEntryP->globalsP);					// get our globals handle from the entry		// Free our library globals	if ( gH )		{		libEntryP->globalsP = NULL;							// clear our globals reference		MemHandleFree(gH);										// free our globals		}}/************************************************************ * *  FUNCTION: PrvLockGlobals * *  DESCRIPTION:	Lock our library globals. * *  PARAMETERS:	refNum		-- Sample library reference number * *  CALLED BY:		internal * *  RETURNS:		pointer to our library globals; NULL if our globals *						have not been created yet. * *  CREATED: 5/20/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static NSBTreoLibGlobalsPtr PrvLockGlobals(UInt16 refNum){	NSBTreoLibGlobalsPtr	gP = NULL;	MemHandle				gH;	SysLibTblEntryPtr		libEntryP;	libEntryP = SysLibTblEntry(refNum);						// get our system library table entry	if ( libEntryP )		gH = (MemHandle)(libEntryP->globalsP);				// get our globals handle from the entry	if ( gH )		gP = (NSBTreoLibGlobalsPtr)MemHandleLock(gH);		// lock our globals	return( gP );}/************************************************************ * *  FUNCTION: PrvIsLibOpen * *  DESCRIPTION:	Check if the library has been opened. * *  PARAMETERS:	refNum		-- Sample library reference number * *  CALLED BY:		internal * *  RETURNS:		non-zero if the library has been opened * *  CREATED: 6/9/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static Boolean PrvIsLibOpen(UInt16 refNum){	NSBTreoLibGlobalsPtr	gP;	Boolean	isOpen = false;		gP = PrvLockGlobals(refNum);		if ( gP )		{		isOpen = true;		PrvUnlockGlobals(gP);		}		return( isOpen );}/************************************************************ * *  FUNCTION: PrvCreateClientContext * *  DESCRIPTION:	Create a client context for storing client-specific data. *						The client context allows the library to support multiple clients. * *  PARAMETERS:	gP						-- pointer to our locked globals *						clientContextP		-- pointer to variable for returning client context * *  CALLED BY:		Anyone wishing to create a client context * *  RETURNS:		0						-- no error *						sampleErrNotOpen	-- the library is not open *						sampleErrMemory	-- insufficient memory * *						*clientContextP will be set to client context on success, or zero on error. * *  CREATED: 6/9/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static Err PrvCreateClientContext(NSBTreoLibGlobalsPtr gP, UInt32 * clientContextP){	Err								err = 0;	MemHandle						contextH;	NSBTreoLibClientContextPtr	contextP;		// Error-check our parameters	ErrFatalDisplayIf(gP == NULL, "null globals pointer");	ErrFatalDisplayIf(clientContextP == NULL, "Null context variable pointer");			// Initialize return variable	*clientContextP = 0;		// Allocate a new client context structure	contextH = MemHandleNew(sizeof(NSBTreoLibClientContextType));	if ( !contextH )		{		err = sampleErrMemory;		}	else		{		*clientContextP = (UInt32)contextH;			// save context chunk handle in return variable				// Initialize the context chunk		contextP = (NSBTreoLibClientContextPtr)MemHandleLock(contextH);		// lock context chunk		contextP->wSignature = sampleLibContextSignature;		// contextP->cornerDiam = sampleDefaultCornerDiameter;		PrvUnlockContext(contextP);													// unlock the context		gP->contextCount++;			// increment context count (for debugging)		ErrFatalDisplayIf(gP->contextCount == 0, "Context count overflow");		}	return( err );}/************************************************************ * *  FUNCTION: PrvDestroyClientContext * *  DESCRIPTION:	Destroy a client context which was created by PrvCreateClientContext. * *  PARAMETERS:	gP						-- pointer to our locked globals *						clientContext		-- client context * *  CALLED BY:		Anyone wishing to create a client context * *  RETURNS:		0						-- no error *						sampleErrNotOpen	-- the library is not open * *  CREATED: 6/9/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static Err PrvDestroyClientContext(NSBTreoLibGlobalsPtr gP, UInt32 clientContext){	NSBTreoLibClientContextPtr	contextP;		// Error-check our parameters	ErrFatalDisplayIf(gP == NULL, "Null globals pointer");	// Validate the client context by locking it	contextP = PrvLockContext(clientContext);		if ( contextP )		{		MemPtrFree(contextP);		// freeing a locked chunk is permitted by the system		gP->contextCount--;			// decrement context count (for debugging)		ErrFatalDisplayIf(gP->contextCount < 0, "context count underflow");		}		return( 0 );}/************************************************************ * *  FUNCTION: PrvLockContext * *  DESCRIPTION:	Validate and lock a client context. * *  PARAMETERS:	context		-- a client context to lock * *  CALLED BY:		internal * *  RETURNS:		pointer to the locked client context. * *  CREATED: 6/9/97  * *  BY: vmk * *  REVISION HISTORY: *			Name	Date		Description *			----	----		----------- * *************************************************************/static NSBTreoLibClientContextPtr PrvLockContext(UInt32 context){	NSBTreoLibClientContextPtr	contextP = NULL;			// Error-check our parameters	ErrFatalDisplayIf(context == 0, "Null client context");		// Lock the client context	contextP = (NSBTreoLibClientContextPtr)MemHandleLock((MemHandle)context);	ErrFatalDisplayIf(contextP == NULL, "Failed to lock client context");	// should not happen		// Validate the client context	ErrFatalDisplayIf(contextP->wSignature != sampleLibContextSignature, "invalid client context");			return( contextP );}/*********************************************************************** * * FUNCTION:    GetRingProfile * * DESCRIPTION: Returns the ring/vibrate profile *  * Treo 700p: *  profile:	Ring tones,		0 * 		Phone alerts,	6 * 		Calendar,		2 * 		Messaging,		5 * 	vol:	Ringer volume, 	0 through 7 (0 = Off) * 	vib:	Vibrate mode, 	0 = Never * 				1 = When sound off * 				256 = Vibrate then ring * 				257 = Always *  * Compatability:  GSM, CDMA * ***********************************************************************/Err GetRingProfile(UInt16 refNum, UInt16 profile, Int16 *vol, Int16 *vib, Int16 *result ) {	UInt32 HsPhCreatorID='HsTo';	UInt16 HsPhPrefID=profile;	struct {		UInt16 fill_1;		UInt16 fill_2;		UInt16 fill_3;		UInt16 fill_4;		UInt16 fill_5;		UInt16 fill_6;		UInt16 fill_7;		UInt16 fill_8;		UInt16 fill_9;		UInt16 fill_10;		UInt16 fill_11;		UInt16 fill_12;		UInt16 fill_13;		UInt16 volume;		UInt16 vibrate;	}  prefs;		UInt16 prefsSize=0;	// Check size of preferences.  If not 30 bytes, something	// has changed since the time this lib was designed	if (PrefGetAppPreferences(HsPhCreatorID, HsPhPrefID, NULL, &prefsSize, 								true)!= noPreferenceFound) 									if (prefsSize != sizeof(prefs)) {									// unexpected prefSize, better not continue										*result = -2;										return 0;									}	if (PrefGetAppPreferences(HsPhCreatorID, HsPhPrefID, &prefs, &prefsSize,                              true) != noPreferenceFound) {								*vol = prefs.volume;								*vib = prefs.vibrate;								*result = 0;                              }                              else {                              	*result = -1;                              }		return 0;}                       /*********************************************************************** * * FUNCTION:    SetRingProfile * * DESCRIPTION: Sets the ring/vibrate profile *  * Treo 700p: *  profile:	Ring tones,		0 * 		Phone alerts,	6 * 		Calendar,		2 * 		Messaging,		5 * 	vol:	Ringer volume, 	0 through 7 (0 = Off) * 	vib:	Vibrate mode, 	0 = Never * 				1 = When sound off * 				256 = Vibrate then ring * 				257 = Always *  * Compatability:  GSM, CDMA * * DESCRIPTION: Second sample library function that does the same as A. * ***********************************************************************/Err SetRingProfile(UInt16 refNum, UInt16 profile, Int16 vol, Int16 vib, Int16 *result ) {	UInt32 HsPhCreatorID='HsTo';	UInt16 HsPhPrefID=profile;   	Int16 prefsVersion;	struct {		UInt16 fill_1;		UInt16 fill_2;		UInt16 fill_3;		UInt16 fill_4;		UInt16 fill_5;		UInt16 fill_6;		UInt16 fill_7;		UInt16 fill_8;		UInt16 fill_9;		UInt16 fill_10;		UInt16 fill_11;		UInt16 fill_12;		UInt16 fill_13;		UInt16 volume;		UInt16 vibrate;	}  prefs;		UInt16 prefsSize=0;	// Check size of preferences.  If not 30 bytes, something	// has changed since the time this lib was designed	if (PrefGetAppPreferences(HsPhCreatorID, HsPhPrefID, NULL, &prefsSize, 								true)!= noPreferenceFound) 									if (prefsSize != sizeof(prefs)) {									// unexpected prefSize, better not continue										*result = -3;										return 0;									}	// This time, pick up the version number	prefsVersion = PrefGetAppPreferences(HsPhCreatorID, HsPhPrefID, &prefs, &prefsSize, true);	if (prefsVersion != noPreferenceFound) {		*result=prefsVersion;	}	else {		*result = -2;		return 0;	}	prefs.volume=vol;	prefs.vibrate=vib;	PrefSetAppPreferences(HsPhCreatorID, HsPhPrefID, prefsVersion, &prefs, prefsSize, true);	if (prefsSize != sizeof(prefs)) {		// Seems that the preferences didn't update?		*result = -1;	}	else {		*result = 0;	}	return errNone;}  /*********************************************************************** * * FUNCTION:    GetRoamWarnings * * DESCRIPTION: Returns the roam-specific application preferences * * 	Treo 700p: * 		result   0: Warn before call & Warn before data unchecked * 		result   1: Warn before data checked *  		result 256: Warn before call checked * 		result 257: Warn before call & Warn before data checked *  * Compatability:  CDMA only (?) *  ***********************************************************************/Err GetRoamWarnings(UInt16 refNum, Int16 *result) {	UInt32 HsPhCreatorID='HsPh';	UInt16 HsPhPrefID=0x0D;   	Int16 prefs;	UInt16 prefsSize;    prefsSize = sizeof(prefs);	if (PrefGetAppPreferences(HsPhCreatorID, HsPhPrefID, &prefs, &prefsSize,                              true) != noPreferenceFound) {								*result = prefs;                              }                              else {                              	*result = -1;                              }		return 0;}                       /*********************************************************************** * * FUNCTION:    SetRoamWarnings * * DESCRIPTION: Sets the roam-specific application preferences * * 	Treo 700p: * 		warnings   0: Warn before call & Warn before data unchecked * 		warnings   1: Warn before data checked *  		warnings 256: Warn before call checked * 		warnings 257: Warn before call & Warn before data checked *  * Compatability:  CDMA only (?) *  ***********************************************************************/Err SetRoamWarnings(UInt16 refNum, UInt16 warnings, Int16 *result) {	UInt32 HsPhCreatorID='HsPh';	UInt16 HsPhPrefID=0x0D;   	UInt16 prefs=0;   	Int16 prefsVersion;	UInt16 prefsSize=0;	// Check size of preferences.  If not 16 bytes, something	// has changed since the time this lib was designed	if (PrefGetAppPreferences(HsPhCreatorID, HsPhPrefID, NULL, &prefsSize, 								true)!= noPreferenceFound) 									if (prefsSize != sizeof(prefs)) {									// unexpected prefSize, better not continue										*result = -3;										return 0;									}										// This time, pick up the version number	prefsVersion = PrefGetAppPreferences(HsPhCreatorID, HsPhPrefID, &prefs, &prefsSize, true);	if (prefsVersion != noPreferenceFound) {		*result=prefsVersion;	}	else {		*result = -2;		return 0;	}	prefs=warnings;	PrefSetAppPreferences(HsPhCreatorID, HsPhPrefID, prefsVersion, &prefs, prefsSize, true);	if (prefsSize != sizeof(prefs)) {		// Seems that the preferences didn't update?		*result = -1;	}	else {		*result = 0;	}	return errNone;}                       /*********************************************************************** * * FUNCTION:    PhonePower * * DESCRIPTION: Turns radio module power on or off directly without * 				the user prompt used by HsPowerOn *  * Compatability:  GSM, CDMA *  * ***********************************************************************/Err PhonePower(UInt16 refNum, char *offOn, Int16 *result) {	Boolean doWhat;	UInt16 hsRef;	if (!StrCompare(offOn,"off")) 		doWhat = false;	else {		if (!StrCompare(offOn,"on")) 			doWhat = true;		else {			*result = -3;			return 0;		}	}		// Get reference number to Handspring phone library	// and return -2 if error occurs finding library	if ( HsGetPhoneLibrary( &hsRef ) ) {		*result = -2;		return 0;	}			if (PhnLibSetModulePower (hsRef, doWhat))		*result = -1;	else		*result = 0;	return 0;}/*********************************************************************** * * FUNCTION:    GetLibRefNum * * DESCRIPTION: Returns the library reference number of PhnLib * * Compatability:  GSM, CDMA *  ***********************************************************************/Err GetLibRefNum(UInt16 refNum, UInt16 *result) {	UInt16 phoneLibRef=0; 	if (!HsGetPhoneLibrary(&phoneLibRef))		*result = phoneLibRef;	else		*result = -1;	return errNone;}       /*********************************************************************** * * FUNCTION:    GetRoamMode * * DESCRIPTION: Returns the current roaming mode *  * 	Treo 700p:	0 Home Only (ie roaming is disabled) *			1 Any (ie roaming is enabled) *			2 Roam Only (ie roaming is required) *  *	Treo 650	0 Home Only (ie roaming is disabled) *			1 Any (ie roaming is enabled) *  * Compatability:  CDMA only *  ***********************************************************************/Err GetRoamMode(UInt16 refNum, Int16 *result ) {	UInt16 hsRef;	//PhnRoamPrefSelectionType hsMode;	UInt8 hsMode;	//check phonetype (GSM / CDMA) first	UInt32 phnType = hsAttrPhoneTypeGSM; 	HsAttrGet (hsAttrPhoneType, 0, &phnType);	if (phnType == hsAttrPhoneTypeGSM) {		*result = -4;		return 0;	}		// Get reference number to Handspring phone library	// and return -3 if error occurs finding library	if ( HsGetPhoneLibrary( &hsRef ) ) {		*result = -3;		return 0;	}	// Check to ensure radio is on before proceeding	// and return -2 if radio is off	if ( !PhnLibModulePowered( hsRef ) )	{		*result = -2;		return 0;	}		// Get current roaming preference mode from phone	// and return -1 if error occurs else roaming mode	if ( PhnLibGetRoamPrefMode( hsRef, &hsMode ) )		*result = -1;	else		*result = hsMode;	return 0;}/*********************************************************************** * * FUNCTION:    SetRoamMode * * 	Treo 700p:	0 Home Only (ie roaming is disabled) *			1 Any (ie roaming is enabled) *			2 Roam Only (ie roaming is required) *  *	Treo 650	0 Home Only (ie roaming is disabled) *			1 Any (ie roaming is enabled) *  * Compatability:  CDMA only * ***********************************************************************/Err SetRoamMode(UInt16 refNum, Int16 mode, Int16 *result) {	UInt16 hsRef;	//PhnRoamPrefSelectionType hsMode=mode;	UInt8 hsMode=mode;	//check phonetype (GSM / CDMA) first	UInt32 phnType = hsAttrPhoneTypeGSM; 	HsAttrGet (hsAttrPhoneType, 0, &phnType);	if (phnType == hsAttrPhoneTypeGSM) {		*result = -5;		return 0;	}			// Get reference number to Handspring phone library	// and return -4 if error occurs finding library	if ( HsGetPhoneLibrary( &hsRef ) ) {		*result = -4;		return 0;	}	// Check to ensure radio is on before proceeding	// and return -3 if radio is off	if ( !PhnLibModulePowered( hsRef ) )	{		*result = -3;		return 0;	}	// Check for valid prefMode request	// and return -2 if outside range	if (hsMode > 2) {		*result = -2;		return 0;	}				// Set roaming preference mode 	// Return -1 if error occurs else roaming mode	if ( PhnLibSetRoamPrefMode( hsRef, hsMode ) ) {		*result = -1;	}	else {		*result = hsMode;	}	return 0;}